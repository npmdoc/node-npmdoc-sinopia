<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/rlidwka/sinopia">sinopia (v1.4.0)</a>
</h1>
<h4>Private npm repository server</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia">module sinopia</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.sinopia">
            function <span class="apidocSignatureSpan"></span>sinopia
            <span class="apidocSignatureSpan">(config_hash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.auth">
            function <span class="apidocSignatureSpan">sinopia.</span>auth
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.config">
            function <span class="apidocSignatureSpan">sinopia.</span>config
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_data">
            function <span class="apidocSignatureSpan">sinopia.</span>local_data
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage">
            function <span class="apidocSignatureSpan">sinopia.</span>local_storage
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.storage">
            function <span class="apidocSignatureSpan">sinopia.</span>storage
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.up_storage">
            function <span class="apidocSignatureSpan">sinopia.</span>up_storage
            <span class="apidocSignatureSpan">(config, mainconfig)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sinopia.</span>auth.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sinopia.</span>config.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sinopia.</span>local_data.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sinopia.</span>local_fs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sinopia.</span>local_storage.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sinopia.</span>logger</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sinopia.</span>middleware</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sinopia.</span>plugin_loader</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sinopia.</span>status_cats</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sinopia.</span>storage.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sinopia.</span>streams</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sinopia.</span>up_storage.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">sinopia.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.auth">module sinopia.auth</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.auth.auth">
            function <span class="apidocSignatureSpan">sinopia.</span>auth
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.auth.prototype">module sinopia.auth.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.auth.prototype.add_user">
            function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>add_user
            <span class="apidocSignatureSpan">(user, password, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.auth.prototype.aes_decrypt">
            function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>aes_decrypt
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.auth.prototype.aes_encrypt">
            function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>aes_encrypt
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.auth.prototype.allow_access">
            function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>allow_access
            <span class="apidocSignatureSpan">(package_name, user, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.auth.prototype.allow_publish">
            function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>allow_publish
            <span class="apidocSignatureSpan">(package_name, user, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.auth.prototype.authenticate">
            function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>authenticate
            <span class="apidocSignatureSpan">(user, password, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.auth.prototype.basic_middleware">
            function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>basic_middleware
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.auth.prototype.bearer_middleware">
            function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>bearer_middleware
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.auth.prototype.cookie_middleware">
            function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>cookie_middleware
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.auth.prototype.decode_token">
            function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>decode_token
            <span class="apidocSignatureSpan">(str, expire_time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.auth.prototype.issue_token">
            function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>issue_token
            <span class="apidocSignatureSpan">(user)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.config">module sinopia.config</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.config.config">
            function <span class="apidocSignatureSpan">sinopia.</span>config
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.config.parse_interval">
            function <span class="apidocSignatureSpan">sinopia.config.</span>parse_interval
            <span class="apidocSignatureSpan">(interval)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.config.prototype">module sinopia.config.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.config.prototype.can_proxy_to">
            function <span class="apidocSignatureSpan">sinopia.config.prototype.</span>can_proxy_to
            <span class="apidocSignatureSpan">(package, uplink)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.config.prototype.get_package_spec">
            function <span class="apidocSignatureSpan">sinopia.config.prototype.</span>get_package_spec
            <span class="apidocSignatureSpan">(package)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.local_data">module sinopia.local_data</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_data.local_data">
            function <span class="apidocSignatureSpan">sinopia.</span>local_data
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.local_data.prototype">module sinopia.local_data.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_data.prototype.add">
            function <span class="apidocSignatureSpan">sinopia.local_data.prototype.</span>add
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_data.prototype.get">
            function <span class="apidocSignatureSpan">sinopia.local_data.prototype.</span>get
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_data.prototype.remove">
            function <span class="apidocSignatureSpan">sinopia.local_data.prototype.</span>remove
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_data.prototype.sync">
            function <span class="apidocSignatureSpan">sinopia.local_data.prototype.</span>sync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.local_fs">module sinopia.local_fs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_fs.create">
            function <span class="apidocSignatureSpan">sinopia.local_fs.</span>create
            <span class="apidocSignatureSpan">(name, contents, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_fs.create_json">
            function <span class="apidocSignatureSpan">sinopia.local_fs.</span>create_json
            <span class="apidocSignatureSpan">(name, value, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_fs.lock_and_read">
            function <span class="apidocSignatureSpan">sinopia.local_fs.</span>lock_and_read
            <span class="apidocSignatureSpan">(name, _callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_fs.lock_and_read_json">
            function <span class="apidocSignatureSpan">sinopia.local_fs.</span>lock_and_read_json
            <span class="apidocSignatureSpan">(name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_fs.read">
            function <span class="apidocSignatureSpan">sinopia.local_fs.</span>read
            <span class="apidocSignatureSpan">(name, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_fs.read_json">
            function <span class="apidocSignatureSpan">sinopia.local_fs.</span>read_json
            <span class="apidocSignatureSpan">(name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_fs.read_stream">
            function <span class="apidocSignatureSpan">sinopia.local_fs.</span>read_stream
            <span class="apidocSignatureSpan">(name, stream, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_fs.rmdir">
            function <span class="apidocSignatureSpan">sinopia.local_fs.</span>rmdir
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_fs.unlink">
            function <span class="apidocSignatureSpan">sinopia.local_fs.</span>unlink
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_fs.update">
            function <span class="apidocSignatureSpan">sinopia.local_fs.</span>update
            <span class="apidocSignatureSpan">(name, contents, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_fs.update_json">
            function <span class="apidocSignatureSpan">sinopia.local_fs.</span>update_json
            <span class="apidocSignatureSpan">(name, value, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_fs.write">
            function <span class="apidocSignatureSpan">sinopia.local_fs.</span>write
            <span class="apidocSignatureSpan">(dest, data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_fs.write_json">
            function <span class="apidocSignatureSpan">sinopia.local_fs.</span>write_json
            <span class="apidocSignatureSpan">(name, value, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_fs.write_stream">
            function <span class="apidocSignatureSpan">sinopia.local_fs.</span>write_stream
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.local_storage">module sinopia.local_storage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.local_storage">
            function <span class="apidocSignatureSpan">sinopia.</span>local_storage
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.local_storage.prototype">module sinopia.local_storage.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype._each_package">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>_each_package
            <span class="apidocSignatureSpan">(on_package, on_end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype._internal_error">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>_internal_error
            <span class="apidocSignatureSpan">(err, file, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype._normalize_package">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>_normalize_package
            <span class="apidocSignatureSpan">(pkg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype._read_create_package">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>_read_create_package
            <span class="apidocSignatureSpan">(name, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype._write_package">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>_write_package
            <span class="apidocSignatureSpan">(name, json, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype.add_package">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>add_package
            <span class="apidocSignatureSpan">(name, info, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype.add_tarball">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>add_tarball
            <span class="apidocSignatureSpan">(name, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype.add_version">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>add_version
            <span class="apidocSignatureSpan">(name, version, metadata, tag, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype.change_package">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>change_package
            <span class="apidocSignatureSpan">(name, metadata, revision, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype.get_package">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>get_package
            <span class="apidocSignatureSpan">(name, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype.get_tarball">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>get_tarball
            <span class="apidocSignatureSpan">(name, filename, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype.merge_tags">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>merge_tags
            <span class="apidocSignatureSpan">(name, tags, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype.remove_package">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>remove_package
            <span class="apidocSignatureSpan">(name, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype.remove_tarball">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>remove_tarball
            <span class="apidocSignatureSpan">(name, filename, revision, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype.replace_tags">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>replace_tags
            <span class="apidocSignatureSpan">(name, tags, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype.search">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>search
            <span class="apidocSignatureSpan">(startkey, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype.storage">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>storage
            <span class="apidocSignatureSpan">(package)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype.update_package">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>update_package
            <span class="apidocSignatureSpan">(name, updateFn, _callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.local_storage.prototype.update_versions">
            function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>update_versions
            <span class="apidocSignatureSpan">(name, newdata, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.logger">module sinopia.logger</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.logger.setup">
            function <span class="apidocSignatureSpan">sinopia.logger.</span>setup
            <span class="apidocSignatureSpan">(logs)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.middleware">module sinopia.middleware</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.middleware.allow">
            function <span class="apidocSignatureSpan">sinopia.middleware.</span>allow
            <span class="apidocSignatureSpan">(auth)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.middleware.anti_loop">
            function <span class="apidocSignatureSpan">sinopia.middleware.</span>anti_loop
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.middleware.expect_json">
            function <span class="apidocSignatureSpan">sinopia.middleware.</span>expect_json
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.middleware.final">
            function <span class="apidocSignatureSpan">sinopia.middleware.</span>final
            <span class="apidocSignatureSpan">(body, req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.middleware.log">
            function <span class="apidocSignatureSpan">sinopia.middleware.</span>log
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.middleware.match">
            function <span class="apidocSignatureSpan">sinopia.middleware.</span>match
            <span class="apidocSignatureSpan">(regexp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.middleware.media">
            function <span class="apidocSignatureSpan">sinopia.middleware.</span>media
            <span class="apidocSignatureSpan">(expect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.middleware.validate_name">
            function <span class="apidocSignatureSpan">sinopia.middleware.</span>validate_name
            <span class="apidocSignatureSpan">(req, res, next, value, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.middleware.validate_package">
            function <span class="apidocSignatureSpan">sinopia.middleware.</span>validate_package
            <span class="apidocSignatureSpan">(req, res, next, value, name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.plugin_loader">module sinopia.plugin_loader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.plugin_loader.load_plugins">
            function <span class="apidocSignatureSpan">sinopia.plugin_loader.</span>load_plugins
            <span class="apidocSignatureSpan">(config, plugin_configs, params, sanity_check)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.status_cats">module sinopia.status_cats</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.status_cats.get_image">
            function <span class="apidocSignatureSpan">sinopia.status_cats.</span>get_image
            <span class="apidocSignatureSpan">(status)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.status_cats.middleware">
            function <span class="apidocSignatureSpan">sinopia.status_cats.</span>middleware
            <span class="apidocSignatureSpan">(req, res, next)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.storage">module sinopia.storage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.storage.storage">
            function <span class="apidocSignatureSpan">sinopia.</span>storage
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.storage._merge_versions">
            function <span class="apidocSignatureSpan">sinopia.storage.</span>_merge_versions
            <span class="apidocSignatureSpan">(local, up, config)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.storage.prototype">module sinopia.storage.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.storage.prototype._sync_package_with_uplinks">
            function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>_sync_package_with_uplinks
            <span class="apidocSignatureSpan">(name, pkginfo, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.storage.prototype.add_package">
            function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>add_package
            <span class="apidocSignatureSpan">(name, metadata, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.storage.prototype.add_tarball">
            function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>add_tarball
            <span class="apidocSignatureSpan">(name, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.storage.prototype.add_version">
            function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>add_version
            <span class="apidocSignatureSpan">(name, version, metadata, tag, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.storage.prototype.change_package">
            function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>change_package
            <span class="apidocSignatureSpan">(name, metadata, revision, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.storage.prototype.get_local">
            function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>get_local
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.storage.prototype.get_package">
            function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>get_package
            <span class="apidocSignatureSpan">(name, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.storage.prototype.get_tarball">
            function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>get_tarball
            <span class="apidocSignatureSpan">(name, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.storage.prototype.merge_tags">
            function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>merge_tags
            <span class="apidocSignatureSpan">(name, tag_hash, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.storage.prototype.remove_package">
            function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>remove_package
            <span class="apidocSignatureSpan">(name, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.storage.prototype.remove_tarball">
            function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>remove_tarball
            <span class="apidocSignatureSpan">(name, filename, revision, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.storage.prototype.replace_tags">
            function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>replace_tags
            <span class="apidocSignatureSpan">(name, tag_hash, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.storage.prototype.search">
            function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>search
            <span class="apidocSignatureSpan">(startkey, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.streams">module sinopia.streams</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.streams.ReadTarballStream">
            function <span class="apidocSignatureSpan">sinopia.streams.</span>ReadTarballStream
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.streams.UploadTarballStream">
            function <span class="apidocSignatureSpan">sinopia.streams.</span>UploadTarballStream
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.up_storage">module sinopia.up_storage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.up_storage.up_storage">
            function <span class="apidocSignatureSpan">sinopia.</span>up_storage
            <span class="apidocSignatureSpan">(config, mainconfig)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.up_storage.prototype">module sinopia.up_storage.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.up_storage.prototype._add_proxy_headers">
            function <span class="apidocSignatureSpan">sinopia.up_storage.prototype.</span>_add_proxy_headers
            <span class="apidocSignatureSpan">(req, headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.up_storage.prototype.can_fetch_url">
            function <span class="apidocSignatureSpan">sinopia.up_storage.prototype.</span>can_fetch_url
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.up_storage.prototype.get_package">
            function <span class="apidocSignatureSpan">sinopia.up_storage.prototype.</span>get_package
            <span class="apidocSignatureSpan">(name, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.up_storage.prototype.get_tarball">
            function <span class="apidocSignatureSpan">sinopia.up_storage.prototype.</span>get_tarball
            <span class="apidocSignatureSpan">(name, options, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.up_storage.prototype.get_url">
            function <span class="apidocSignatureSpan">sinopia.up_storage.prototype.</span>get_url
            <span class="apidocSignatureSpan">(url)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.up_storage.prototype.request">
            function <span class="apidocSignatureSpan">sinopia.up_storage.prototype.</span>request
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.up_storage.prototype.search">
            function <span class="apidocSignatureSpan">sinopia.up_storage.prototype.</span>search
            <span class="apidocSignatureSpan">(startkey, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.up_storage.prototype.status_check">
            function <span class="apidocSignatureSpan">sinopia.up_storage.prototype.</span>status_check
            <span class="apidocSignatureSpan">(alive)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.sinopia.utils">module sinopia.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.utils.filter_tarball_urls">
            function <span class="apidocSignatureSpan">sinopia.utils.</span>filter_tarball_urls
            <span class="apidocSignatureSpan">(pkg, req, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.utils.get_version">
            function <span class="apidocSignatureSpan">sinopia.utils.</span>get_version
            <span class="apidocSignatureSpan">(object, version)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.utils.is_object">
            function <span class="apidocSignatureSpan">sinopia.utils.</span>is_object
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.utils.parse_address">
            function <span class="apidocSignatureSpan">sinopia.utils.</span>parse_address
            <span class="apidocSignatureSpan">(addr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.utils.semver_sort">
            function <span class="apidocSignatureSpan">sinopia.utils.</span>semver_sort
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.utils.tag_version">
            function <span class="apidocSignatureSpan">sinopia.utils.</span>tag_version
            <span class="apidocSignatureSpan">(data, version, tag, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.utils.validate_metadata">
            function <span class="apidocSignatureSpan">sinopia.utils.</span>validate_metadata
            <span class="apidocSignatureSpan">(object, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.utils.validate_name">
            function <span class="apidocSignatureSpan">sinopia.utils.</span>validate_name
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.sinopia.utils.validate_package">
            function <span class="apidocSignatureSpan">sinopia.utils.</span>validate_package
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia" id="apidoc.module.sinopia">module sinopia</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.sinopia" id="apidoc.element.sinopia.sinopia">
        function <span class="apidocSignatureSpan"></span>sinopia
        <span class="apidocSignatureSpan">(config_hash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sinopia = function (config_hash) {
  Logger.setup(config_hash.logs)

  var config  = Config(config_hash)
  var storage = Storage(config)
  var auth    = Auth(config)
  var app     = express()

  // run in production mode by default, just in case
  // it shouldn't make any difference anyway
  app.set('env', process.env.NODE_ENV || 'production')

  function error_reporting_middleware(req, res, next) {
    res.report_error = res.report_error || function(err) {
      if (err.status &amp;&amp; err.status &gt;= 400 &amp;&amp; err.status &lt; 600) {
        if (!res.headersSent) {
          res.status(err.status)
          next({ error: err.message || 'unknown error' })
        }
      } else {
        Logger.logger.error( { err: err }
                           , 'unexpected error: @{!err.message}\n@{err.stack}')
        if (!res.status || !res.send) {
          Logger.logger.error('this is an error in express.js, please report this')
          res.destroy()
        } else if (!res.headersSent) {
          res.status(500)
          next({ error: 'internal server error' })
        } else {
          // socket should be already closed
        }
      }
    }
    next()
  }

  app.use(Middleware.log)
  app.use(error_reporting_middleware)
  app.use(function(req, res, next) {
    res.setHeader('X-Powered-By', config.user_agent)
    next()
  })
  app.use(Cats.middleware)
  app.use(compression())

  app.get('/favicon.ico', function(req, res, next) {
    req.url = '/-/static/favicon.png'
    next()
  })

  // hook for tests only
  if (config._debug) {
    app.get('/-/_debug', function(req, res, next) {
      var do_gc = typeof(global.gc) !== 'undefined'
      if (do_gc) global.gc()
      next({
        pid  : process.pid,
        main : process.mainModule.filename,
        conf : config.self_path,
        mem  : process.memoryUsage(),
        gc   : do_gc,
      })
    })
  }

  app.use(require('./index-api')(config, auth, storage))

  if (config.web &amp;&amp; config.web.enable === false) {
    app.get('/', function(req, res, next) {
      next( Error[404]('web interface is disabled in the config file') )
    })
  } else {
    app.use(require('./index-web')(config, auth, storage))
  }

  app.get('/*', function(req, res, next) {
    next( Error[404]('file not found') )
  })

  app.use(function(err, req, res, next) {
    if (Object.prototype.toString.call(err) !== '[object Error]') return next(err)
    if (err.code === 'ECONNABORT' &amp;&amp; res.statusCode === 304) return next()
    if (typeof(res.report_error) !== 'function') {
      // in case of very early error this middleware may not be loaded before error is generated
      // fixing that
      error_reporting_middleware(req, res, function(){})
    }
    res.report_error(err)
  })

  app.use(Middleware.final)

  return app
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.auth" id="apidoc.element.sinopia.auth">
        function <span class="apidocSignatureSpan">sinopia.</span>auth
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Auth(config) {
  var self = Object.create(Auth.prototype)
  self.config = config
  self.logger = Logger.logger.child({ sub: 'auth' })
  self.secret = config.secret

  var plugin_params = {
    config: config,
    logger: self.logger
  }

  if (config.users_file) {
    if (!config.auth || !config.auth.htpasswd) {
      // b/w compat
      config.auth = config.auth || {}
      config.auth.htpasswd = { file: config.users_file }
    }
  }

  self.plugins = load_plugins(config, config.auth, plugin_params, function (p) {
    return p.authenticate || p.allow_access || p.allow_publish
  })

  self.plugins.unshift({
    sinopia_version: '1.1.0',

    authenticate: function(user, password, cb) {
      if (config.users != null
       &amp;&amp; config.users[user] != null
       &amp;&amp; (Crypto.createHash('sha1').update(password).digest('hex')
            === config.users[user].password)
      ) {
        return cb(null, [ user ])
      }

      return cb()
    },

    adduser: function(user, password, cb) {
      if (config.users &amp;&amp; config.users[user])
        return cb( Error[403]('this user already exists') )

      return cb()
    },
  })

  function allow_action(action) {
    return function(user, package, cb) {
      var ok = package[action].reduce(function(prev, curr) {
        if (user.groups.indexOf(curr) !== -1) return true
        return prev
      }, false)

      if (ok) return cb(null, true)

      if (user.name) {
        cb( Error[403]('user ' + user.name + ' is not allowed to ' + action + ' package ' + package.name) )
      } else {
        cb( Error[403]('unregistered users are not allowed to ' + action + ' package ' + package.name) )
      }
    }
  }

  self.plugins.push({
    authenticate: function(user, password, cb) {
      return cb( Error[403]('bad username/password, access denied') )
    },

    add_user: function(user, password, cb) {
      return cb( Error[409]('registration is disabled') )
    },

    allow_access: allow_action('access'),
    allow_publish: allow_action('publish'),
  })

  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.config" id="apidoc.element.sinopia.config">
        function <span class="apidocSignatureSpan">sinopia.</span>config
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Config(config) {
  var self = Object.create(Config.prototype)
  for (var i in config) {
    if (self[i] == null) self[i] = config[i]
  }
  if (!self.user_agent) self.user_agent = 'Sinopia/'+pkg.version

  // some weird shell scripts are valid yaml files parsed as string
  assert.equal(typeof(config), 'object', 'CONFIG: it doesn\'t look like a valid config file')

  assert(self.storage, 'CONFIG: storage path not defined')
  self.localList = LocalData(
    Path.join(
      Path.resolve(Path.dirname(self.self_path), self.storage),
      '.sinopia-db.json'
    )
  )
  if (!self.secret) {
    self.secret = self.localList.data.secret

    if (!self.secret) {
      self.secret = Crypto.pseudoRandomBytes(32).toString('hex')
      self.localList.data.secret = self.secret
      self.localList.sync()
    }
  }

  var users = {all:true, anonymous:true, 'undefined':true, owner:true, none:true}

  var check_user_or_uplink = function(arg) {
    assert(arg !== 'all' &amp;&amp; arg !== 'owner' &amp;&amp; arg !== 'anonymous' &amp;&amp; arg !== 'undefined' &amp;&amp; arg !== 'none', 'CONFIG: reserved user
/uplink name: ' + arg)
    assert(!arg.match(/\s/), 'CONFIG: invalid user name: ' + arg)
    assert(users[arg] == null, 'CONFIG: duplicate user/uplink name: ' + arg)
    users[arg] = true
  }

  ;[ 'users', 'uplinks', 'packages' ].forEach(function(x) {
    if (self[x] == null) self[x] = {}
    assert(Utils.is_object(self[x]), 'CONFIG: bad "'+x+'" value (object expected)')
  })

  for (var i in self.users) check_user_or_uplink(i)
  for (var i in self.uplinks) check_user_or_uplink(i)

  for (var i in self.users) {
    assert(self.users[i].password, 'CONFIG: no password for user: ' + i)
    assert(
      typeof(self.users[i].password) === 'string' &amp;&amp;
      self.users[i].password.match(/^[a-f0-9]{40}$/)
    , 'CONFIG: wrong password format for user: ' + i + ', sha1 expected')
  }

  for (var i in self.uplinks) {
    assert(self.uplinks[i].url, 'CONFIG: no url for uplink: ' + i)
    assert( typeof(self.uplinks[i].url) === 'string'
          , 'CONFIG: wrong url format for uplink: ' + i)
    self.uplinks[i].url = self.uplinks[i].url.replace(/\/$/, '')
  }

  function normalize_userlist() {
    var result = []

    for (var i=0; i&lt;arguments.length; i++) {
      if (arguments[i] == null) continue

      // if it's a string, split it to array
      if (typeof(arguments[i]) === 'string') {
        result.push(arguments[i].split(/\s+/))
      } else if (Array.isArray(arguments[i])) {
        result.push(arguments[i])
      } else {
        throw Error('CONFIG: bad package acl (array or string expected): ' + JSON.stringify(arguments[i]))
      }
    }
    return flatten(result)
  }

  // add a default rule for all packages to make writing plugins easier
  if (self.packages['**'] == null) {
    self.packages['**'] = {}
  }

  for (var i in self.packages) {
    assert(
      typeof(self.packages[i]) === 'object' &amp;&amp;
      !Array.isArray(self.packages[i])
    , 'CONFIG: bad "'+i+'" package description (object expected)')

    self.packages[i].access = normalize_userlist(
      self.packages[i].allow_access,
      self.packages[i].access
    );
    delete self.packages[i].allow_access

    self.packages[i].publish = normalize_userlist(
      self.packages[i].allow_publish,
      self.packages[i].publish
    );
    delete self.packages[i].allow_publish

    self.packages[i].proxy = normalize_userlist(
      self.packages[i].proxy_access,
      self.packages[i].proxy
    );
    delete self.packages[i].proxy_access
  }

  // loading these from ENV if aren't in config
  ;[ 'http_proxy', 'https_proxy', 'no_proxy' ].forEach((function(v) {
    if (!(v in self)) {
      self[v] = process.env[v] || process.env[v.toUpperCase()]
    }
  }).bind(self))

  // unique identifier of self server (or a cluster), used to avoid loops
  if (!self.server_id) {
    self.server_id = Crypto.pseudoRandomBytes(6).toString('hex')
  }

  if (self.ignore_latest_tag == null) self.ignore_latest_tag = false

  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_data" id="apidoc.element.sinopia.local_data">
        function <span class="apidocSignatureSpan">sinopia.</span>local_data
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LocalData(path) {
  var self = Object.create(LocalData.prototype)
  self.path = path
  try {
    self.data = JSON.parse(fs.readFileSync(self.path, 'utf8'))
  } catch(_) {
    self.data = { list: [] }
  }
  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage" id="apidoc.element.sinopia.local_storage">
        function <span class="apidocSignatureSpan">sinopia.</span>local_storage
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Storage(config) {
  var self = Object.create(Storage.prototype)
  self.config = config
  self.logger = Logger.logger.child({ sub: 'fs' })
  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.storage" id="apidoc.element.sinopia.storage">
        function <span class="apidocSignatureSpan">sinopia.</span>storage
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Storage(config) {
  var self = Object.create(Storage.prototype)
  self.config = config

  // we support a number of uplinks, but only one local storage
  // Proxy and Local classes should have similar API interfaces
  self.uplinks = {}
  for (var p in config.uplinks) {
    self.uplinks[p] = Proxy(config.uplinks[p], config)
    self.uplinks[p].upname = p
  }
  self.local = Local(config)
  self.logger = Logger.logger.child()

  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Storage.prototype._internal_error = function(err, file, message) {
this.logger.error( { err: err, file: file }
                 , message + ' @{file}: @{!err.message}' )
return Error[500]()
}

Storage.prototype.add_package = function(name, info, callback) {
var storage = this.<span class="apidocCodeKeywordSpan">storage</span>(name)
if (!storage) return callback( Error[404]('this package cannot be added') )

storage.create_json(info_file, get_boilerplate(name), function(err) {
  if (err &amp;&amp; err.code === 'EEXISTS') {
    return callback( Error[409]('this package is already present') )
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.up_storage" id="apidoc.element.sinopia.up_storage">
        function <span class="apidocSignatureSpan">sinopia.</span>up_storage
        <span class="apidocSignatureSpan">(config, mainconfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Storage(config, mainconfig) {
  var self = Object.create(Storage.prototype)
  self.config = config
  self.failed_requests = 0
  self.userAgent = mainconfig.user_agent
  self.ca = config.ca
  self.logger = Logger.logger.child({sub: 'out'})
  self.server_id = mainconfig.server_id

  self.url = URL.parse(self.config.url)

  _setupProxy.call(self, self.url.hostname, config, mainconfig, self.url.protocol === 'https:')

  self.config.url = self.config.url.replace(/\/$/, '')
  if (Number(self.config.timeout) &gt;= 1000) {
    self.logger.warn([ 'Too big timeout value: ' + self.config.timeout,
                       'We changed time format to nginx-like one',
                       '(see http://wiki.nginx.org/ConfigNotation)',
                       'so please update your config accordingly' ].join('\n'))
  }

  // a bunch of different configurable timers
  self.maxage       = parse_interval(config_get('maxage'      , '2m' ))
  self.timeout      = parse_interval(config_get('timeout'     , '30s'))
  self.max_fails    =         Number(config_get('max_fails'   ,  2   ))
  self.fail_timeout = parse_interval(config_get('fail_timeout', '5m' ))
  return self

  // just a helper (`config[key] || default` doesn't work because of zeroes)
  function config_get(key, def) {
    return config[key] != null ? config[key] : def
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.auth" id="apidoc.module.sinopia.auth">module sinopia.auth</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.auth.auth" id="apidoc.element.sinopia.auth.auth">
        function <span class="apidocSignatureSpan">sinopia.</span>auth
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Auth(config) {
  var self = Object.create(Auth.prototype)
  self.config = config
  self.logger = Logger.logger.child({ sub: 'auth' })
  self.secret = config.secret

  var plugin_params = {
    config: config,
    logger: self.logger
  }

  if (config.users_file) {
    if (!config.auth || !config.auth.htpasswd) {
      // b/w compat
      config.auth = config.auth || {}
      config.auth.htpasswd = { file: config.users_file }
    }
  }

  self.plugins = load_plugins(config, config.auth, plugin_params, function (p) {
    return p.authenticate || p.allow_access || p.allow_publish
  })

  self.plugins.unshift({
    sinopia_version: '1.1.0',

    authenticate: function(user, password, cb) {
      if (config.users != null
       &amp;&amp; config.users[user] != null
       &amp;&amp; (Crypto.createHash('sha1').update(password).digest('hex')
            === config.users[user].password)
      ) {
        return cb(null, [ user ])
      }

      return cb()
    },

    adduser: function(user, password, cb) {
      if (config.users &amp;&amp; config.users[user])
        return cb( Error[403]('this user already exists') )

      return cb()
    },
  })

  function allow_action(action) {
    return function(user, package, cb) {
      var ok = package[action].reduce(function(prev, curr) {
        if (user.groups.indexOf(curr) !== -1) return true
        return prev
      }, false)

      if (ok) return cb(null, true)

      if (user.name) {
        cb( Error[403]('user ' + user.name + ' is not allowed to ' + action + ' package ' + package.name) )
      } else {
        cb( Error[403]('unregistered users are not allowed to ' + action + ' package ' + package.name) )
      }
    }
  }

  self.plugins.push({
    authenticate: function(user, password, cb) {
      return cb( Error[403]('bad username/password, access denied') )
    },

    add_user: function(user, password, cb) {
      return cb( Error[409]('registration is disabled') )
    },

    allow_access: allow_action('access'),
    allow_publish: allow_action('publish'),
  })

  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.auth.prototype" id="apidoc.module.sinopia.auth.prototype">module sinopia.auth.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.auth.prototype.add_user" id="apidoc.element.sinopia.auth.prototype.add_user">
        function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>add_user
        <span class="apidocSignatureSpan">(user, password, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add_user = function (user, password, cb) {
  var self = this
  var plugins = this.plugins.slice(0)

  ;(function next() {
    var p = plugins.shift()
    var n = 'adduser'
    if (typeof(p[n]) !== 'function') {
      n = 'add_user'
    }
    if (typeof(p[n]) !== 'function') {
      next()
    } else {
      p[n](user, password, function(err, ok) {
        if (err) return cb(err)
        if (ok) return self.authenticate(user, password, cb)
        next()
      })
    }
  })()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.auth.prototype.aes_decrypt" id="apidoc.element.sinopia.auth.prototype.aes_decrypt">
        function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>aes_decrypt
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">aes_decrypt = function (buf) {
  try {
    var c = Crypto.createDecipher('aes192', this.secret)
    var b1 = c.update(buf)
    var b2 = c.final()
  } catch(_) {
    return Buffer(0)
  }
  return Buffer.concat([ b1, b2 ])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (parts.length !== 2)
  return next( Error[400]('bad authorization header') )

var scheme = parts[0]
if (scheme === 'Basic') {
  var credentials = Buffer(parts[1], 'base64').toString()
} else if (scheme === 'Bearer') {
  var credentials = self.<span class="apidocCodeKeywordSpan">aes_decrypt</span>(Buffer(parts[1], 'base64')).toString(&amp;#
x27;utf8')
  if (!credentials) return next()
} else {
  return next()
}

var index = credentials.indexOf(':')
if (index &lt; 0) return next()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.auth.prototype.aes_encrypt" id="apidoc.element.sinopia.auth.prototype.aes_encrypt">
        function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>aes_encrypt
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">aes_encrypt = function (buf) {
  var c = Crypto.createCipher('aes192', this.secret)
  var b1 = c.update(buf)
  var b2 = c.final()
  return Buffer.concat([ b1, b2 ])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.auth.prototype.allow_access" id="apidoc.element.sinopia.auth.prototype.allow_access">
        function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>allow_access
        <span class="apidocSignatureSpan">(package_name, user, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allow_access = function (package_name, user, callback) {
  var plugins = this.plugins.slice(0)
  var package = Object.assign({ name: package_name },
                              this.config.get_package_spec(package_name))

  ;(function next() {
    var p = plugins.shift()

    if (typeof(p.allow_access) !== 'function') {
      return next()
    }

    p.allow_access(user, package, function(err, ok) {
      if (err) return callback(err)
      if (ok) return callback(null, ok)
      next() // cb(null, false) causes next plugin to roll
    })
  })()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ;(function next() {
    var p = plugins.shift()

    if (typeof(p.allow_access) !== 'function') {
      return next()
    }

    p.<span class="apidocCodeKeywordSpan">allow_access</span>(user, package, function(err, ok) {
      if (err) return callback(err)
      if (ok) return callback(null, ok)
      next() // cb(null, false) causes next plugin to roll
    })
  })()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.auth.prototype.allow_publish" id="apidoc.element.sinopia.auth.prototype.allow_publish">
        function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>allow_publish
        <span class="apidocSignatureSpan">(package_name, user, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allow_publish = function (package_name, user, callback) {
  var plugins = this.plugins.slice(0)
  var package = Object.assign({ name: package_name },
                              this.config.get_package_spec(package_name))

  ;(function next() {
    var p = plugins.shift()

    if (typeof(p.allow_publish) !== 'function') {
      return next()
    }

    p.allow_publish(user, package, function(err, ok) {
      if (err) return callback(err)
      if (ok) return callback(null, ok)
      next() // cb(null, false) causes next plugin to roll
    })
  })()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ;(function next() {
    var p = plugins.shift()

    if (typeof(p.allow_publish) !== 'function') {
      return next()
    }

    p.<span class="apidocCodeKeywordSpan">allow_publish</span>(user, package, function(err, ok) {
      if (err) return callback(err)
      if (ok) return callback(null, ok)
      next() // cb(null, false) causes next plugin to roll
    })
  })()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.auth.prototype.authenticate" id="apidoc.element.sinopia.auth.prototype.authenticate">
        function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>authenticate
        <span class="apidocSignatureSpan">(user, password, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authenticate = function (user, password, cb) {
  var plugins = this.plugins.slice(0)

  ;(function next() {
    var p = plugins.shift()

    if (typeof(p.authenticate) !== 'function') {
      return next()
    }

    p.authenticate(user, password, function(err, groups) {
      if (err) return cb(err)
      if (groups != null &amp;&amp; groups != false)
        return cb(err, AuthenticatedUser(user, groups))
      next()
    })
  })()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ;(function next() {
    var p = plugins.shift()

    if (typeof(p.authenticate) !== 'function') {
      return next()
    }

    p.<span class="apidocCodeKeywordSpan">authenticate</span>(user, password, function(err, groups) {
      if (err) return cb(err)
      if (groups != null &amp;&amp; groups != false)
        return cb(err, AuthenticatedUser(user, groups))
      next()
    })
  })()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.auth.prototype.basic_middleware" id="apidoc.element.sinopia.auth.prototype.basic_middleware">
        function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>basic_middleware
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">basic_middleware = function () {
  var self = this
  return function(req, res, _next) {
    req.pause()
    function next(err) {
      req.resume()
      // uncomment this to reject users with bad auth headers
      //return _next.apply(null, arguments)

      // swallow error, user remains unauthorized
      // set remoteUserError to indicate that user was attempting authentication
      if (err) req.remote_user.error = err.message
      return _next()
    }

    if (req.remote_user != null &amp;&amp; req.remote_user.name !== undefined)
      return next()
    req.remote_user = AnonymousUser()

    var authorization = req.headers.authorization
    if (authorization == null) return next()

    var parts = authorization.split(' ')

    if (parts.length !== 2)
      return next( Error[400]('bad authorization header') )

    var scheme = parts[0]
    if (scheme === 'Basic') {
      var credentials = Buffer(parts[1], 'base64').toString()
    } else if (scheme === 'Bearer') {
      var credentials = self.aes_decrypt(Buffer(parts[1], 'base64')).toString('utf8')
      if (!credentials) return next()
    } else {
      return next()
    }

    var index = credentials.indexOf(':')
    if (index &lt; 0) return next()

    var user = credentials.slice(0, index)
    var pass = credentials.slice(index + 1)

    self.authenticate(user, pass, function(err, user) {
      if (!err) {
        req.remote_user = user
        next()
      } else {
        req.remote_user = AnonymousUser()
        next(err)
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.auth.prototype.bearer_middleware" id="apidoc.element.sinopia.auth.prototype.bearer_middleware">
        function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>bearer_middleware
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bearer_middleware = function () {
  var self = this
  return function(req, res, _next) {
    req.pause()
    function next(_err) {
      req.resume()
      return _next.apply(null, arguments)
    }

    if (req.remote_user != null &amp;&amp; req.remote_user.name !== undefined)
      return next()
    req.remote_user = AnonymousUser()

    var authorization = req.headers.authorization
    if (authorization == null) return next()

    var parts = authorization.split(' ')

    if (parts.length !== 2)
      return next( Error[400]('bad authorization header') )

    var scheme = parts[0]
    var token = parts[1]

    if (scheme !== 'Bearer')
      return next()

    try {
      var user = self.decode_token(token)
    } catch(err) {
      return next(err)
    }

    req.remote_user = AuthenticatedUser(user.u, user.g)
    req.remote_user.token = token
    next()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.auth.prototype.cookie_middleware" id="apidoc.element.sinopia.auth.prototype.cookie_middleware">
        function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>cookie_middleware
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cookie_middleware = function () {
  var self = this
  return function(req, res, _next) {
    req.pause()
    function next(_err) {
      req.resume()
      return _next()
    }

    if (req.remote_user != null &amp;&amp; req.remote_user.name !== undefined)
      return next()

    req.remote_user = AnonymousUser()

    var token = req.cookies.get('token')
    if (token == null) return next()

<span class="apidocCodeCommentSpan">    /*try {
      var user = self.decode_token(token, 60*60)
    } catch(err) {
      return next()
    }

    req.remote_user = AuthenticatedUser(user.u, user.g)
    req.remote_user.token = token
    next()*/
</span>    var credentials = self.aes_decrypt(Buffer(token, 'base64')).toString('utf8')
    if (!credentials) return next()

    var index = credentials.indexOf(':')
    if (index &lt; 0) return next()

    var user = credentials.slice(0, index)
    var pass = credentials.slice(index + 1)

    self.authenticate(user, pass, function(err, user) {
      if (!err) {
        req.remote_user = user
        next()
      } else {
        req.remote_user = AnonymousUser()
        next(err)
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.auth.prototype.decode_token" id="apidoc.element.sinopia.auth.prototype.decode_token">
        function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>decode_token
        <span class="apidocSignatureSpan">(str, expire_time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode_token = function (str, expire_time) {
  var buf = Buffer(str, 'base64')
  if (buf.length &lt;= 32) throw Error[401]('invalid token')

  var data      = buf.slice(0, buf.length - 32)
  var their_mac = buf.slice(buf.length - 32)
  var good_mac  = Crypto.createHmac('sha256', this.secret).update(data).digest()

  their_mac = Crypto.createHash('sha512').update(their_mac).digest('hex')
  good_mac  = Crypto.createHash('sha512').update(good_mac).digest('hex')
  if (their_mac !== good_mac) throw Error[401]('bad signature')

  // make token expire in 24 hours
  // TODO: make configurable?
  expire_time = expire_time || 24*60*60

  data = jju.parse(data.toString('utf8'))
  if (Math.abs(data.t - ~~(Date.now()/1000)) &gt; expire_time)
    throw Error[401]('token expired')

  return data
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var scheme = parts[0]
var token = parts[1]

if (scheme !== 'Bearer')
  return next()

try {
  var user = self.<span class="apidocCodeKeywordSpan">decode_token</span>(token)
} catch(err) {
  return next(err)
}

req.remote_user = AuthenticatedUser(user.u, user.g)
req.remote_user.token = token
next()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.auth.prototype.issue_token" id="apidoc.element.sinopia.auth.prototype.issue_token">
        function <span class="apidocSignatureSpan">sinopia.auth.prototype.</span>issue_token
        <span class="apidocSignatureSpan">(user)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">issue_token = function (user) {
  var data = jju.stringify({
    u: user.name,
    g: user.real_groups &amp;&amp; user.real_groups.length ? user.real_groups : undefined,
    t: ~~(Date.now()/1000),
  }, { indent: false })

  data = Buffer(data, 'utf8')
  var mac = Crypto.createHmac('sha256', this.secret).update(data).digest()
  return Buffer.concat([ data, mac ]).toString('base64')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.config" id="apidoc.module.sinopia.config">module sinopia.config</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.config.config" id="apidoc.element.sinopia.config.config">
        function <span class="apidocSignatureSpan">sinopia.</span>config
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Config(config) {
  var self = Object.create(Config.prototype)
  for (var i in config) {
    if (self[i] == null) self[i] = config[i]
  }
  if (!self.user_agent) self.user_agent = 'Sinopia/'+pkg.version

  // some weird shell scripts are valid yaml files parsed as string
  assert.equal(typeof(config), 'object', 'CONFIG: it doesn\'t look like a valid config file')

  assert(self.storage, 'CONFIG: storage path not defined')
  self.localList = LocalData(
    Path.join(
      Path.resolve(Path.dirname(self.self_path), self.storage),
      '.sinopia-db.json'
    )
  )
  if (!self.secret) {
    self.secret = self.localList.data.secret

    if (!self.secret) {
      self.secret = Crypto.pseudoRandomBytes(32).toString('hex')
      self.localList.data.secret = self.secret
      self.localList.sync()
    }
  }

  var users = {all:true, anonymous:true, 'undefined':true, owner:true, none:true}

  var check_user_or_uplink = function(arg) {
    assert(arg !== 'all' &amp;&amp; arg !== 'owner' &amp;&amp; arg !== 'anonymous' &amp;&amp; arg !== 'undefined' &amp;&amp; arg !== 'none', 'CONFIG: reserved user
/uplink name: ' + arg)
    assert(!arg.match(/\s/), 'CONFIG: invalid user name: ' + arg)
    assert(users[arg] == null, 'CONFIG: duplicate user/uplink name: ' + arg)
    users[arg] = true
  }

  ;[ 'users', 'uplinks', 'packages' ].forEach(function(x) {
    if (self[x] == null) self[x] = {}
    assert(Utils.is_object(self[x]), 'CONFIG: bad "'+x+'" value (object expected)')
  })

  for (var i in self.users) check_user_or_uplink(i)
  for (var i in self.uplinks) check_user_or_uplink(i)

  for (var i in self.users) {
    assert(self.users[i].password, 'CONFIG: no password for user: ' + i)
    assert(
      typeof(self.users[i].password) === 'string' &amp;&amp;
      self.users[i].password.match(/^[a-f0-9]{40}$/)
    , 'CONFIG: wrong password format for user: ' + i + ', sha1 expected')
  }

  for (var i in self.uplinks) {
    assert(self.uplinks[i].url, 'CONFIG: no url for uplink: ' + i)
    assert( typeof(self.uplinks[i].url) === 'string'
          , 'CONFIG: wrong url format for uplink: ' + i)
    self.uplinks[i].url = self.uplinks[i].url.replace(/\/$/, '')
  }

  function normalize_userlist() {
    var result = []

    for (var i=0; i&lt;arguments.length; i++) {
      if (arguments[i] == null) continue

      // if it's a string, split it to array
      if (typeof(arguments[i]) === 'string') {
        result.push(arguments[i].split(/\s+/))
      } else if (Array.isArray(arguments[i])) {
        result.push(arguments[i])
      } else {
        throw Error('CONFIG: bad package acl (array or string expected): ' + JSON.stringify(arguments[i]))
      }
    }
    return flatten(result)
  }

  // add a default rule for all packages to make writing plugins easier
  if (self.packages['**'] == null) {
    self.packages['**'] = {}
  }

  for (var i in self.packages) {
    assert(
      typeof(self.packages[i]) === 'object' &amp;&amp;
      !Array.isArray(self.packages[i])
    , 'CONFIG: bad "'+i+'" package description (object expected)')

    self.packages[i].access = normalize_userlist(
      self.packages[i].allow_access,
      self.packages[i].access
    );
    delete self.packages[i].allow_access

    self.packages[i].publish = normalize_userlist(
      self.packages[i].allow_publish,
      self.packages[i].publish
    );
    delete self.packages[i].allow_publish

    self.packages[i].proxy = normalize_userlist(
      self.packages[i].proxy_access,
      self.packages[i].proxy
    );
    delete self.packages[i].proxy_access
  }

  // loading these from ENV if aren't in config
  ;[ 'http_proxy', 'https_proxy', 'no_proxy' ].forEach((function(v) {
    if (!(v in self)) {
      self[v] = process.env[v] || process.env[v.toUpperCase()]
    }
  }).bind(self))

  // unique identifier of self server (or a cluster), used to avoid loops
  if (!self.server_id) {
    self.server_id = Crypto.pseudoRandomBytes(6).toString('hex')
  }

  if (self.ignore_latest_tag == null) self.ignore_latest_tag = false

  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.config.parse_interval" id="apidoc.element.sinopia.config.parse_interval">
        function <span class="apidocSignatureSpan">sinopia.config.</span>parse_interval
        <span class="apidocSignatureSpan">(interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_interval = function (interval) {
  if (typeof(interval) === 'number') return interval * 1000

  var result = 0
  var last_suffix = Infinity
  interval.split(/\s+/).forEach(function(x) {
    if (!x) return
    var m = x.match(/^((0|[1-9][0-9]*)(\.[0-9]+)?)(ms|s|m|h|d|w|M|y|)$/)
    if (!m
    ||  parse_interval_table[m[4]] &gt;= last_suffix
    ||  (m[4] === '' &amp;&amp; last_suffix !== Infinity)) {
      throw Error('invalid interval: ' + interval)
    }
    last_suffix = parse_interval_table[m[4]]
    result += Number(m[1]) * parse_interval_table[m[4]]
  })
  return result
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.config.prototype" id="apidoc.module.sinopia.config.prototype">module sinopia.config.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.config.prototype.can_proxy_to" id="apidoc.element.sinopia.config.prototype.can_proxy_to">
        function <span class="apidocSignatureSpan">sinopia.config.prototype.</span>can_proxy_to
        <span class="apidocSignatureSpan">(package, uplink)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_proxy_to = function (package, uplink) {
  return (this.get_package_spec(package).proxy || []).reduce(function(prev, curr) {
    if (uplink === curr) return true
    return prev
  }, false)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
} else {
  var exists = true
}

var uplinks = []
for (var i in self.uplinks) {
  if (self.config.<span class="apidocCodeKeywordSpan">can_proxy_to</span>(name, i)) {
    uplinks.push(self.uplinks[i])
  }
}

async.map(uplinks, function(up, cb) {
  var _options = Object.assign({}, options)
  if (Utils.is_object(pkginfo._uplinks[up.upname])) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.config.prototype.get_package_spec" id="apidoc.element.sinopia.config.prototype.get_package_spec">
        function <span class="apidocSignatureSpan">sinopia.config.prototype.</span>get_package_spec
        <span class="apidocSignatureSpan">(package)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_package_spec = function (package) {
  for (var i in this.packages) {
    if (minimatch.makeRe(i).exec(package)) {
      return this.packages[i]
    }
  }
  return {}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
  })()
}

Auth.prototype.allow_access = function(package_name, user, callback) {
  var plugins = this.plugins.slice(0)
  var package = Object.assign({ name: package_name },
                          this.config.<span class="apidocCodeKeywordSpan">get_package_spec</span>(package_name))

  ;(function next() {
var p = plugins.shift()

if (typeof(p.allow_access) !== 'function') {
  return next()
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.local_data" id="apidoc.module.sinopia.local_data">module sinopia.local_data</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.local_data.local_data" id="apidoc.element.sinopia.local_data.local_data">
        function <span class="apidocSignatureSpan">sinopia.</span>local_data
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LocalData(path) {
  var self = Object.create(LocalData.prototype)
  self.path = path
  try {
    self.data = JSON.parse(fs.readFileSync(self.path, 'utf8'))
  } catch(_) {
    self.data = { list: [] }
  }
  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.local_data.prototype" id="apidoc.module.sinopia.local_data.prototype">module sinopia.local_data.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.local_data.prototype.add" id="apidoc.element.sinopia.local_data.prototype.add">
        function <span class="apidocSignatureSpan">sinopia.local_data.prototype.</span>add
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (name) {
  if (this.data.list.indexOf(name) === -1) {
    this.data.list.push(name)
    this.sync()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
storage.create_json(info_file, get_boilerplate(name), function(err) {
  if (err &amp;&amp; err.code === 'EEXISTS') {
    return callback( Error[409]('this package is already present') )
  }

  var latest = info['dist-tags'].latest
  if (latest &amp;&amp; info.versions[latest]) {
    Search.<span class="apidocCodeKeywordSpan">add</span>(info.versions[latest])
  }
  callback()
})
}

Storage.prototype.remove_package = function(name, callback) {
var self = this
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_data.prototype.get" id="apidoc.element.sinopia.local_data.prototype.get">
        function <span class="apidocSignatureSpan">sinopia.local_data.prototype.</span>get
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function () {
  return this.data.list
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (req.remote_user != null &amp;&amp; req.remote_user.name !== undefined)
  return next()

req.remote_user = AnonymousUser()

var token = req.cookies.<span class="apidocCodeKeywordSpan">get</span>('token')
if (token == null) return next()

/*try {
  var user = self.decode_token(token, 60*60)
} catch(err) {
  return next()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_data.prototype.remove" id="apidoc.element.sinopia.local_data.prototype.remove">
        function <span class="apidocSignatureSpan">sinopia.local_data.prototype.</span>remove
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (name) {
  var i = this.data.list.indexOf(name)
  if (i !== -1) {
    this.data.list.splice(i, 1)
  }

  this.sync()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      storage.rmdir('.', function(err) {
        callback(err)
      })
    })
  })
})

Search.<span class="apidocCodeKeywordSpan">remove</span>(name)
this.config.localList.remove(name)
}

Storage.prototype._read_create_package = function(name, callback) {
var self = this
var storage = self.storage(name)
if (!storage) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_data.prototype.sync" id="apidoc.element.sinopia.local_data.prototype.sync">
        function <span class="apidocSignatureSpan">sinopia.local_data.prototype.</span>sync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sync = function () {
  // Uses sync to prevent ugly race condition
  try {
    require('mkdirp').sync(Path.dirname(this.path))
  } catch(err) {}
  fs.writeFileSync(this.path, JSON.stringify(this.data))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

create_config_file(paths[0])
return paths[0].path
}

function create_config_file(config_path) {
require('mkdirp').<span class="apidocCodeKeywordSpan">sync</span>(Path.dirname(config_path.path))
logger.logger.info({ file: config_path.path }, 'Creating default config file in @{file}')

var created_config = fs.readFileSync(require.resolve('../conf/default.yaml'), 'utf8')

if (config_path.type === 'xdg') {
  var data_dir = process.env.XDG_DATA_HOME
              || Path.join(process.env.HOME, '.local', 'share')
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.local_fs" id="apidoc.module.sinopia.local_fs">module sinopia.local_fs</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.local_fs.create" id="apidoc.element.sinopia.local_fs.create">
        function <span class="apidocSignatureSpan">sinopia.local_fs.</span>create
        <span class="apidocSignatureSpan">(name, contents, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(name, contents, callback) {
  fs.exists(name, function(exists) {
    if (exists) return callback( FSError('EEXISTS') )
    write(name, contents, callback)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Error        = require('http-errors')
var Logger       = require('./logger')
var load_plugins = require('./plugin-loader').load_plugins

module.exports = Auth

function Auth(config) {
var self = Object.<span class="apidocCodeKeywordSpan">create</span>(Auth.prototype)
self.config = config
self.logger = Logger.logger.child({ sub: 'auth' })
self.secret = config.secret

var plugin_params = {
  config: config,
  logger: self.logger
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_fs.create_json" id="apidoc.element.sinopia.local_fs.create_json">
        function <span class="apidocSignatureSpan">sinopia.local_fs.</span>create_json
        <span class="apidocSignatureSpan">(name, value, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create_json = function (name, value, cb) {
  create(name, JSON.stringify(value, null, '\t'), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return Error[500]()
}

Storage.prototype.add_package = function(name, info, callback) {
  var storage = this.storage(name)
  if (!storage) return callback( Error[404]('this package cannot be added') )

  storage.<span class="apidocCodeKeywordSpan">create_json</span>(info_file, get_boilerplate(name), function(err) {
if (err &amp;&amp; err.code === 'EEXISTS') {
  return callback( Error[409]('this package is already present') )
}

var latest = info['dist-tags'].latest
if (latest &amp;&amp; info.versions[latest]) {
  Search.add(info.versions[latest])
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_fs.lock_and_read" id="apidoc.element.sinopia.local_fs.lock_and_read">
        function <span class="apidocSignatureSpan">sinopia.local_fs.</span>lock_and_read
        <span class="apidocSignatureSpan">(name, _callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lock_and_read(name, _callback) {
  open_flock(name, 'r', 'exnb', 4, 10, function(err, fd) {
    function callback(err) {
      if (err &amp;&amp; fd) {
        fs.close(fd, function(err2) {
          _callback(err)
        })
      } else {
        _callback.apply(null, arguments)
      }
    }

    if (err) return callback(err, fd)

    fs.fstat(fd, function(err, st) {
      if (err) return callback(err, fd)

      var buffer = Buffer(st.size)
      if (st.size === 0) return onRead(null, 0, buffer)
      fs.read(fd, buffer, 0, st.size, null, onRead)

      function onRead(err, bytesRead, buffer) {
        if (err) return callback(err, fd)
        if (bytesRead != st.size) return callback(Error('st.size != bytesRead'), fd)

        callback(null, fd, buffer)
      }
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_fs.lock_and_read_json" id="apidoc.element.sinopia.local_fs.lock_and_read_json">
        function <span class="apidocSignatureSpan">sinopia.local_fs.</span>lock_and_read_json
        <span class="apidocSignatureSpan">(name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lock_and_read_json = function (name, cb) {
  lock_and_read(name, function(err, fd, res) {
    if (err) return cb(err, fd)

    var args = []
    try {
      args = [ null, fd, JSON.parse(res.toString('utf8')) ]
    } catch(err) {
      args = [ err, fd ]
    }
    cb.apply(null, args)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 5. move package.json.tmp package.json
// 6. callback(err?)
//
Storage.prototype.update_package = function(name, updateFn, _callback) {
var self = this
var storage = self.storage(name)
if (!storage) return _callback( Error[404]('no such package available') )
storage.<span class="apidocCodeKeywordSpan">lock_and_read_json</span>(info_file, function(err, fd, json) {
  function callback() {
    var _args = arguments
    if (fd) {
      fs.close(fd, function(err) {
        if (err) return _callback(err)
        _callback.apply(null, _args)
      })
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_fs.read" id="apidoc.element.sinopia.local_fs.read">
        function <span class="apidocSignatureSpan">sinopia.local_fs.</span>read
        <span class="apidocSignatureSpan">(name, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read(name, callback) {
  fs.readFile(name, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (err) return callback(err, fd)

    fs.fstat(fd, function(err, st) {
if (err) return callback(err, fd)

var buffer = Buffer(st.size)
if (st.size === 0) return onRead(null, 0, buffer)
fs.<span class="apidocCodeKeywordSpan">read</span>(fd, buffer, 0, st.size, null, onRead)

function onRead(err, bytesRead, buffer) {
  if (err) return callback(err, fd)
  if (bytesRead != st.size) return callback(Error('st.size != bytesRead'), fd)

  callback(null, fd, buffer)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_fs.read_json" id="apidoc.element.sinopia.local_fs.read_json">
        function <span class="apidocSignatureSpan">sinopia.local_fs.</span>read_json
        <span class="apidocSignatureSpan">(name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read_json = function (name, cb) {
  read(name, function(err, res) {
    if (err) return cb(err)

    var args = []
    try {
      args = [ null, JSON.parse(res.toString('utf8')) ]
    } catch(err) {
      args = [ err ]
    }
    cb.apply(null, args)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var self = this
self.logger.info( { name: name }
                , 'unpublishing @{name} (all)')

var storage = self.storage(name)
if (!storage) return callback( Error[404]('no such package available') )

storage.<span class="apidocCodeKeywordSpan">read_json</span>(info_file, function(err, data) {
  if (err) {
    if (err.code === 'ENOENT') {
      return callback( Error[404]('no such package available') )
    } else {
      return callback(err)
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_fs.read_stream" id="apidoc.element.sinopia.local_fs.read_stream">
        function <span class="apidocSignatureSpan">sinopia.local_fs.</span>read_stream
        <span class="apidocSignatureSpan">(name, stream, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read_stream(name, stream, callback) {
  var rstream = fs.createReadStream(name)
  rstream.on('error', function(err) {
    stream.emit('error', err)
  })
  rstream.on('open', function(fd) {
    fs.fstat(fd, function(err, stats) {
      if (err) return stream.emit('error', err)
      stream.emit('content-length', stats.size)
      stream.emit('open')
      rstream.pipe(stream)
    })
  })

  var stream = MyStreams.ReadTarballStream()
  stream.abort = function() {
    rstream.close()
  }
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!storage) {
  process.nextTick(function() {
    stream.emit('error', Error[404]('no such file available'))
  })
  return stream
}

var rstream = storage.<span class="apidocCodeKeywordSpan">read_stream</span>(filename)
rstream.on('error', function(err) {
  if (err &amp;&amp; err.code === 'ENOENT') {
    stream.emit('error', Error(404, 'no such file available'))
  } else {
    stream.emit('error', err)
  }
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_fs.rmdir" id="apidoc.element.sinopia.local_fs.rmdir">
        function <span class="apidocSignatureSpan">sinopia.local_fs.</span>rmdir
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rmdir = function (path, callback) {
  callback = maybeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.rmdir(pathModule._makeLong(path), req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      storage.unlink(file, function() {
        unlinkNext(cb)
      })
    }

    unlinkNext(function() {
      // try to unlink the directory, but ignore errors because it can fail
      storage.<span class="apidocCodeKeywordSpan">rmdir</span>('.', function(err) {
        callback(err)
      })
    })
  })
})

Search.remove(name)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_fs.unlink" id="apidoc.element.sinopia.local_fs.unlink">
        function <span class="apidocSignatureSpan">sinopia.local_fs.</span>unlink
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlink = function (path, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.unlink(pathModule._makeLong(path), req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function tempFile(str) {
return str + '.tmp' + String(Math.random()).substr(2)
}

function renameTmp(src, dst, _cb) {
function cb(err) {
  if (err) fs.<span class="apidocCodeKeywordSpan">unlink</span>(src)
  _cb(err)
}

if (process.platform !== 'win32') {
  return fs.rename(src, dst, cb)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_fs.update" id="apidoc.element.sinopia.local_fs.update">
        function <span class="apidocSignatureSpan">sinopia.local_fs.</span>update
        <span class="apidocSignatureSpan">(name, contents, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function update(name, contents, callback) {
  fs.exists(name, function(exists) {
    if (!exists) return callback( FSError('ENOENT') )
    write(name, contents, callback)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  self.plugins.unshift({
sinopia_version: '1.1.0',

authenticate: function(user, password, cb) {
  if (config.users != null
   &amp;&amp; config.users[user] != null
   &amp;&amp; (Crypto.createHash('sha1').<span class="apidocCodeKeywordSpan">update</span>(password).digest('hex
')
        === config.users[user].password)
  ) {
    return cb(null, [ user ])
  }

  return cb()
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_fs.update_json" id="apidoc.element.sinopia.local_fs.update_json">
        function <span class="apidocSignatureSpan">sinopia.local_fs.</span>update_json
        <span class="apidocSignatureSpan">(name, value, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update_json = function (name, value, cb) {
  update(name, JSON.stringify(value, null, '\t'), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_fs.write" id="apidoc.element.sinopia.local_fs.write">
        function <span class="apidocSignatureSpan">sinopia.local_fs.</span>write
        <span class="apidocSignatureSpan">(dest, data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write(dest, data, cb) {
  var safe_write = function(cb) {
    var tmpname = tempFile(dest)
    fs.writeFile(tmpname, data, function(err) {
      if (err) return cb(err)
      renameTmp(tmpname, dest, cb)
    })
  }

  safe_write(function(err) {
    if (err &amp;&amp; err.code === 'ENOENT') {
      mkdirp(Path.dirname(dest), function(err) {
        if (err) return cb(err)
        safe_write(cb)
      })
    } else {
      cb(err)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (target.type === 'stdout' || target.type === 'stderr') {
  // destination stream
  var dest = target.type === 'stdout' ? process.stdout : process.stderr

  if (target.format === 'pretty') {
    // making fake stream for prettypritting
    stream.write = function(obj) {
      dest.<span class="apidocCodeKeywordSpan">write</span>(print(obj.level, obj.msg, obj, dest.isTTY) + '\n')
    }
  } else {
    stream.write = function(obj) {
      dest.write(JSON.stringify(obj, Logger.safeCycles()) + '\n')
    }
  }
} else if (target.type === 'file') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_fs.write_json" id="apidoc.element.sinopia.local_fs.write_json">
        function <span class="apidocSignatureSpan">sinopia.local_fs.</span>write_json
        <span class="apidocSignatureSpan">(name, value, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write_json = function (name, value, cb) {
  write(name, JSON.stringify(value, null, '\t'), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// calculate revision a la couchdb
if (typeof(json._rev) !== 'string') json._rev = '0-0000000000000000'
var rev = json._rev.split('-')
json._rev = ((+rev[0] || 0) + 1) + '-' + Crypto.pseudoRandomBytes(8).toString('hex')

var storage = this.storage(name)
if (!storage) return callback()
storage.<span class="apidocCodeKeywordSpan">write_json</span>(info_file, json, callback)
}

Storage.prototype.storage = function(package) {
var path = this.config.get_package_spec(package).storage
if (path == null) path = this.config.storage
if (path == null || path === false) {
  this.logger.debug( { name: package }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_fs.write_stream" id="apidoc.element.sinopia.local_fs.write_stream">
        function <span class="apidocSignatureSpan">sinopia.local_fs.</span>write_stream
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write_stream(name) {
  var stream = MyStreams.UploadTarballStream()

  var _ended = 0
  stream.on('end', function() {
    _ended = 1
  })

  fs.exists(name, function(exists) {
    if (exists) return stream.emit('error', FSError('EEXISTS'))

    var tmpname = name + '.tmp-'+String(Math.random()).replace(/^0\./, '')
    var file = fs.createWriteStream(tmpname)
    var opened = false
    stream.pipe(file)

    stream.done = function() {
      function onend() {
        file.on('close', function() {
          renameTmp(tmpname, name, function(err) {
            if (err) {
              stream.emit('error', err)
            } else {
              stream.emit('success')
            }
          })
        })
        file.destroySoon()
      }
      if (_ended) {
        onend()
      } else {
        stream.on('end', onend)
      }
    }
    stream.abort = function() {
      if (opened) {
        opened = false
        file.on('close', function() {
          fs.unlink(tmpname, function(){})
        })
      }
      file.destroySoon()
    }
    file.on('open', function() {
      opened = true
      // re-emitting open because it's handled in storage.js
      stream.emit('open')
    })
    file.on('error', function(err) {
      stream.emit('error', err)
    })
  })
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!storage) {
  process.nextTick(function() {
    stream.emit('error', Error[404]("can't upload this package"))
  })
  return stream
}

var wstream = storage.<span class="apidocCodeKeywordSpan">write_stream</span>(filename)

wstream.on('error', function(err) {
  if (err.code === 'EEXISTS') {
    stream.emit('error', Error[409]('this tarball is already present'))
  } else if (err.code === 'ENOENT') {
    // check if package exists to throw an appropriate message
    self.get_package(name, function(_err, res) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.local_storage" id="apidoc.module.sinopia.local_storage">module sinopia.local_storage</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.local_storage.local_storage" id="apidoc.element.sinopia.local_storage.local_storage">
        function <span class="apidocSignatureSpan">sinopia.</span>local_storage
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Storage(config) {
  var self = Object.create(Storage.prototype)
  self.config = config
  self.logger = Logger.logger.child({ sub: 'fs' })
  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.local_storage.prototype" id="apidoc.module.sinopia.local_storage.prototype">module sinopia.local_storage.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype._each_package" id="apidoc.element.sinopia.local_storage.prototype._each_package">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>_each_package
        <span class="apidocSignatureSpan">(on_package, on_end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_each_package = function (on_package, on_end) {
  var self = this
  var storages = {}

  storages[self.config.storage] = true

  if (self.config.packages) {
    Object.keys(self.packages || {}).map(function (pkg) {
      if (self.config.packages[pkg].storage) {
        storages[self.config.packages[pkg].storage] = true
      }
    })
  }

  var base = Path.dirname(self.config.self_path);

  async.eachSeries(Object.keys(storages), function (storage, cb) {
    fs.readdir(Path.resolve(base, storage), function (err, files) {
      if (err) return cb(err)

      async.eachSeries(files, function (file, cb) {
        if (file.match(/^@/)) {
          // scoped
          fs.readdir(Path.resolve(base, storage, file), function (err, files) {
            if (err) return cb(err)

            async.eachSeries(files, function (file2, cb) {
              if (Utils.validate_name(file2)) {
                on_package({
                  name: file + '/' + file2,
                  path: Path.resolve(base, storage, file, file2),
                }, cb)
              } else {
                cb()
              }
            }, cb)
          })
        } else if (Utils.validate_name(file)) {
          on_package({
            name: file,
            path: Path.resolve(base, storage, file)
          }, cb)
        } else {
          cb()
        }
      }, cb)
    })
  }, on_end)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Storage.prototype.search = function(startkey, options) {
  var self = this

  var stream = new Stream.PassThrough({ objectMode: true })

  self.<span class="apidocCodeKeywordSpan">_each_package</span>(function on_package(item, cb) {
    fs.stat(item.path, function(err, stats) {
if (err) return cb(err)

if (stats.mtime &gt; startkey) {
  self.get_package(item.name, options, function(err, data) {
    if (err) return cb(err)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype._internal_error" id="apidoc.element.sinopia.local_storage.prototype._internal_error">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>_internal_error
        <span class="apidocSignatureSpan">(err, file, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_internal_error = function (err, file, message) {
  this.logger.error( { err: err, file: file }
                   , message + ' @{file}: @{!err.message}' )
  return Error[500]()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  storage.read_json(info_file, function(err, data) {
    // TODO: race condition
    if (err) {
      if (err.code === 'ENOENT') {
        // if package doesn't exist, we create it here
        data = get_boilerplate(name)
      } else {
        return callback(self.<span class="apidocCodeKeywordSpan">_internal_error</span>(err, info_file, 'error reading'
;))
      }
    }
    self._normalize_package(data)
    callback(null, data)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype._normalize_package" id="apidoc.element.sinopia.local_storage.prototype._normalize_package">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>_normalize_package
        <span class="apidocSignatureSpan">(pkg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_normalize_package = function (pkg) {
  ;['versions', 'dist-tags', '_distfiles', '_attachments', '_uplinks'].forEach(function(key) {
    if (!Utils.is_object(pkg[key])) pkg[key] = {}
  })
  if (typeof(pkg._rev) !== 'string') pkg._rev = '0-0000000000000000'
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (err) {
if (err.code === 'ENOENT') {
  return callback( Error[404]('no such package available') )
} else {
  return callback(err)
}
    }
    self.<span class="apidocCodeKeywordSpan">_normalize_package</span>(data)

    storage.unlink(info_file, function(err) {
if (err) return callback(err)

var files = Object.keys(data._attachments)

function unlinkNext(cb) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype._read_create_package" id="apidoc.element.sinopia.local_storage.prototype._read_create_package">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>_read_create_package
        <span class="apidocSignatureSpan">(name, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read_create_package = function (name, callback) {
  var self = this
  var storage = self.storage(name)
  if (!storage) {
    var data = get_boilerplate(name)
    self._normalize_package(data)
    return callback(null, data)
  }
  storage.read_json(info_file, function(err, data) {
    // TODO: race condition
    if (err) {
      if (err.code === 'ENOENT') {
        // if package doesn't exist, we create it here
        data = get_boilerplate(name)
      } else {
        return callback(self._internal_error(err, info_file, 'error reading'))
      }
    }
    self._normalize_package(data)
    callback(null, data)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  })
}

// synchronize remote package info with the local one
// TODO: readfile called twice
Storage.prototype.update_versions = function(name, newdata, callback) {
  var self = this
  self.<span class="apidocCodeKeywordSpan">_read_create_package</span>(name, function(err, data) {
if (err) return callback(err)

var change = false
for (var ver in newdata.versions) {
  if (data.versions[ver] == null) {
    var verdata = newdata.versions[ver]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype._write_package" id="apidoc.element.sinopia.local_storage.prototype._write_package">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>_write_package
        <span class="apidocSignatureSpan">(name, json, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write_package = function (name, json, callback) {

  // calculate revision a la couchdb
  if (typeof(json._rev) !== 'string') json._rev = '0-0000000000000000'
  var rev = json._rev.split('-')
  json._rev = ((+rev[0] || 0) + 1) + '-' + Crypto.pseudoRandomBytes(8).toString('hex')

  var storage = this.storage(name)
  if (!storage) return callback()
  storage.write_json(info_file, json, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (newdata.readme !== data.readme) {
      data.readme = newdata.readme
      change = true
    }

    if (change) {
      self.logger.debug('updating package info')
      self.<span class="apidocCodeKeywordSpan">_write_package</span>(name, data, function(err) {
        callback(err, data)
      })
    } else {
      callback(null, data)
    }
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype.add_package" id="apidoc.element.sinopia.local_storage.prototype.add_package">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>add_package
        <span class="apidocSignatureSpan">(name, info, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add_package = function (name, info, callback) {
  var storage = this.storage(name)
  if (!storage) return callback( Error[404]('this package cannot be added') )

  storage.create_json(info_file, get_boilerplate(name), function(err) {
    if (err &amp;&amp; err.code === 'EEXISTS') {
      return callback( Error[409]('this package is already present') )
    }

    var latest = info['dist-tags'].latest
    if (latest &amp;&amp; info.versions[latest]) {
      Search.add(info.versions[latest])
    }
    callback()
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }

      return cb()
    })
  }

  function publish_package(cb) {
    self.local.<span class="apidocCodeKeywordSpan">add_package</span>(name, metadata, callback)
  }
}

//
// Add a new version of package {name} to a system
//
// Used storages: local (write)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype.add_tarball" id="apidoc.element.sinopia.local_storage.prototype.add_tarball">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>add_tarball
        <span class="apidocSignatureSpan">(name, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add_tarball = function (name, filename) {
  assert(Utils.validate_name(filename))

  var stream = MyStreams.UploadTarballStream()
  var _transform = stream._transform
  var length = 0
  var shasum = Crypto.createHash('sha1')

  stream.abort = stream.done = function(){}

  stream._transform = function(data) {
    shasum.update(data)
    length += data.length
    _transform.apply(stream, arguments)
  }

  var self = this
  if (name === info_file || name === '__proto__') {
    process.nextTick(function() {
      stream.emit('error', Error[403]("can't use this filename"))
    })
    return stream
  }

  var storage = self.storage(name)
  if (!storage) {
    process.nextTick(function() {
      stream.emit('error', Error[404]("can't upload this package"))
    })
    return stream
  }

  var wstream = storage.write_stream(filename)

  wstream.on('error', function(err) {
    if (err.code === 'EEXISTS') {
      stream.emit('error', Error[409]('this tarball is already present'))
    } else if (err.code === 'ENOENT') {
      // check if package exists to throw an appropriate message
      self.get_package(name, function(_err, res) {
        if (_err) {
          stream.emit('error', _err)
        } else {
          stream.emit('error', err)
        }
      })
    } else {
      stream.emit('error', err)
    }
  })

  wstream.on('open', function() {
    // re-emitting open because it's handled in storage.js
    stream.emit('open')
  })
  wstream.on('success', function() {
    self.update_package(name, function updater(data, cb) {
      data._attachments[filename] = {
        shasum: shasum.digest('hex'),
      }
      cb()
    }, function(err) {
      if (err) {
        stream.emit('error', err)
      } else {
        stream.emit('success')
      }
    })
  })
  stream.abort = function() {
    wstream.abort()
  }
  stream.done = function() {
    if (!length) {
      stream.emit('error', Error[422]('refusing to accept zero-length file'))
      wstream.abort()
    } else {
      wstream.done()
    }
  }
  stream.pipe(wstream)

  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Upload a tarball for {name} package
//
// Function is syncronous and returns a WritableStream
//
// Used storages: local (write)
//
Storage.prototype.add_tarball = function(name, filename) {
  return this.local.<span class="apidocCodeKeywordSpan">add_tarball</span>(name, filename)
}

//
// Get a tarball from a storage for {name} package
//
// Function is syncronous and returns a ReadableStream
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype.add_version" id="apidoc.element.sinopia.local_storage.prototype.add_version">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>add_version
        <span class="apidocSignatureSpan">(name, version, metadata, tag, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add_version = function (name, version, metadata, tag, callback) {
  var self = this
  self.update_package(name, function updater(data, cb) {
    // keep only one readme per package
    data.readme = metadata.readme
    delete metadata.readme

    if (data.versions[version] != null) {
      return cb( Error[409]('this version already present') )
    }

    // if uploaded tarball has a different shasum, it's very likely that we have some kind of error
    if (Utils.is_object(metadata.dist) &amp;&amp; typeof(metadata.dist.tarball) === 'string') {
      var tarball = metadata.dist.tarball.replace(/.*\//, '')
      if (Utils.is_object(data._attachments[tarball])) {
        if (data._attachments[tarball].shasum != null &amp;&amp; metadata.dist.shasum != null) {
          if (data._attachments[tarball].shasum != metadata.dist.shasum) {
            return cb( Error[400]('shasum error, '
                                + data._attachments[tarball].shasum
                                + ' != ' + metadata.dist.shasum) )
          }
        }

        data._attachments[tarball].version = version
      }
    }

    data.versions[version] = metadata
    Utils.tag_version(data, version, tag, self.config)
    self.config.localList.add(name)
    cb()
  }, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//
// Add a new version of package {name} to a system
//
// Used storages: local (write)
//
Storage.prototype.add_version = function(name, version, metadata, tag, callback) {
  return this.local.<span class="apidocCodeKeywordSpan">add_version</span>(name, version, metadata, tag, callback)
}

//
// Tags a package version with a provided tag
//
// Used storages: local (write)
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype.change_package" id="apidoc.element.sinopia.local_storage.prototype.change_package">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>change_package
        <span class="apidocSignatureSpan">(name, metadata, revision, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">change_package = function (name, metadata, revision, callback) {
  var self = this

  if (!Utils.is_object(metadata.versions) || !Utils.is_object(metadata['dist-tags'])) {
    return callback( Error[422]('bad data') )
  }

  self.update_package(name, function updater(data, cb) {
    for (var ver in data.versions) {
      if (metadata.versions[ver] == null) {
        self.logger.info( { name: name, version: ver }
                        , 'unpublishing @{name}@@{version}')
        delete data.versions[ver]

        for (var file in data._attachments) {
          if (data._attachments[file].version === ver) {
            delete data._attachments[file].version
          }
        }
      }
    }
    data['dist-tags'] = metadata['dist-tags']
    cb()
  }, function(err) {
    if (err) return callback(err)
    callback()
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// Function changes a package info from local storage and all uplinks with
// write access.
//
// Used storages: local (write)
//
Storage.prototype.change_package = function(name, metadata, revision, callback) {
  return this.local.<span class="apidocCodeKeywordSpan">change_package</span>(name, metadata, revision, callback)
}

//
// Remove a package from a system
//
// Function removes a package from local storage
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype.get_package" id="apidoc.element.sinopia.local_storage.prototype.get_package">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>get_package
        <span class="apidocSignatureSpan">(name, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_package = function (name, options, callback) {
  if (typeof(options) === 'function') callback = options, options = {}

  var self = this
  var storage = self.storage(name)
  if (!storage) return callback( Error[404]('no such package available') )

  storage.read_json(info_file, function(err, result) {
    if (err) {
      if (err.code === 'ENOENT') {
        return callback( Error[404]('no such package available') )
      } else {
        return callback(self._internal_error(err, info_file, 'error reading'))
      }
    }
    self._normalize_package(result)
    callback(err, result)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var wstream = storage.write_stream(filename)

wstream.on('error', function(err) {
  if (err.code === 'EEXISTS') {
    stream.emit('error', Error[409]('this tarball is already present'))
  } else if (err.code === 'ENOENT') {
    // check if package exists to throw an appropriate message
    self.<span class="apidocCodeKeywordSpan">get_package</span>(name, function(_err, res) {
      if (_err) {
        stream.emit('error', _err)
      } else {
        stream.emit('error', err)
      }
    })
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype.get_tarball" id="apidoc.element.sinopia.local_storage.prototype.get_tarball">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>get_tarball
        <span class="apidocSignatureSpan">(name, filename, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_tarball = function (name, filename, callback) {
  assert(Utils.validate_name(filename))
  var self = this

  var stream = MyStreams.ReadTarballStream()
  stream.abort = function() {
    if (rstream) rstream.abort()
  }

  var storage = self.storage(name)
  if (!storage) {
    process.nextTick(function() {
      stream.emit('error', Error[404]('no such file available'))
    })
    return stream
  }

  var rstream = storage.read_stream(filename)
  rstream.on('error', function(err) {
    if (err &amp;&amp; err.code === 'ENOENT') {
      stream.emit('error', Error(404, 'no such file available'))
    } else {
      stream.emit('error', err)
    }
  })
  rstream.on('content-length', function(v) {
    stream.emit('content-length', v)
  })
  rstream.on('open', function() {
    // re-emitting open because it's handled in storage.js
    stream.emit('open')
    rstream.pipe(stream)
  })
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var self = this

  // if someone requesting tarball, it means that we should already have some
  // information about it, so fetching package info is unnecessary

  // trying local first
  var rstream = self.local.<span class="apidocCodeKeywordSpan">get_tarball</span>(name, filename)
  var is_open = false
  rstream.on('error', function(err) {
if (is_open || err.status !== 404) {
  return stream.emit('error', err)
}

// local reported 404
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype.merge_tags" id="apidoc.element.sinopia.local_storage.prototype.merge_tags">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>merge_tags
        <span class="apidocSignatureSpan">(name, tags, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge_tags = function (name, tags, callback) {
  var self = this

  self.update_package(name, function updater(data, cb) {
    for (var t in tags) {
      if (tags[t] === null) {
        delete data['dist-tags'][t]
        continue
      }

      if (data.versions[tags[t]] == null) {
        return cb( Error[404]("this version doesn't exist") )
      }

      Utils.tag_version(data, tags[t], t, self.config)
    }
    cb()
  }, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//
// Tags a package version with a provided tag
//
// Used storages: local (write)
//
Storage.prototype.merge_tags = function(name, tag_hash, callback) {
  return this.local.<span class="apidocCodeKeywordSpan">merge_tags</span>(name, tag_hash, callback)
}

//
// Tags a package version with a provided tag
//
// Used storages: local (write)
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype.remove_package" id="apidoc.element.sinopia.local_storage.prototype.remove_package">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>remove_package
        <span class="apidocSignatureSpan">(name, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove_package = function (name, callback) {
  var self = this
  self.logger.info( { name: name }
                  , 'unpublishing @{name} (all)')

  var storage = self.storage(name)
  if (!storage) return callback( Error[404]('no such package available') )

  storage.read_json(info_file, function(err, data) {
    if (err) {
      if (err.code === 'ENOENT') {
        return callback( Error[404]('no such package available') )
      } else {
        return callback(err)
      }
    }
    self._normalize_package(data)

    storage.unlink(info_file, function(err) {
      if (err) return callback(err)

      var files = Object.keys(data._attachments)

      function unlinkNext(cb) {
        if (files.length === 0) return cb()

        var file = files.shift()
        storage.unlink(file, function() {
          unlinkNext(cb)
        })
      }

      unlinkNext(function() {
        // try to unlink the directory, but ignore errors because it can fail
        storage.rmdir('.', function(err) {
          callback(err)
        })
      })
    })
  })

  Search.remove(name)
  this.config.localList.remove(name)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Remove a package from a system
//
// Function removes a package from local storage
//
// Used storages: local (write)
//
Storage.prototype.remove_package = function(name, callback) {
  return this.local.<span class="apidocCodeKeywordSpan">remove_package</span>(name, callback)
}

//
// Remove a tarball from a system
//
// Function removes a tarball from local storage.
// Tarball in question should not be linked to in any existing
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype.remove_tarball" id="apidoc.element.sinopia.local_storage.prototype.remove_tarball">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>remove_tarball
        <span class="apidocSignatureSpan">(name, filename, revision, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove_tarball = function (name, filename, revision, callback) {
  assert(Utils.validate_name(filename))
  var self = this

  self.update_package(name, function updater(data, cb) {
    if (data._attachments[filename]) {
      delete data._attachments[filename]
      cb()
    } else {
      cb(Error[404]('no such file available'))
    }
  }, function(err) {
    if (err) return callback(err)
    var storage = self.storage(name)
    if (storage) storage.unlink(filename, callback)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Function removes a tarball from local storage.
// Tarball in question should not be linked to in any existing
// versions, i.e. package version should be unpublished first.
//
// Used storages: local (write)
//
Storage.prototype.remove_tarball = function(name, filename, revision, callback) {
  return this.local.<span class="apidocCodeKeywordSpan">remove_tarball</span>(name, filename, revision, callback)
}

//
// Upload a tarball for {name} package
//
// Function is syncronous and returns a WritableStream
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype.replace_tags" id="apidoc.element.sinopia.local_storage.prototype.replace_tags">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>replace_tags
        <span class="apidocSignatureSpan">(name, tags, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace_tags = function (name, tags, callback) {
  var self = this

  self.update_package(name, function updater(data, cb) {
    data['dist-tags'] = {}

    for (var t in tags) {
      if (tags[t] === null) {
        delete data['dist-tags'][t]
        continue
      }

      if (data.versions[tags[t]] == null) {
        return cb( Error[404]("this version doesn't exist") )
      }

      Utils.tag_version(data, tags[t], t, self.config)
    }
    cb()
  }, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//
// Tags a package version with a provided tag
//
// Used storages: local (write)
//
Storage.prototype.replace_tags = function(name, tag_hash, callback) {
  return this.local.<span class="apidocCodeKeywordSpan">replace_tags</span>(name, tag_hash, callback)
}

//
// Change an existing package (i.e. unpublish one version)
//
// Function changes a package info from local storage and all uplinks with
// write access.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype.search" id="apidoc.element.sinopia.local_storage.prototype.search">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>search
        <span class="apidocSignatureSpan">(startkey, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">search = function (startkey, options) {
  var self = this

  var stream = new Stream.PassThrough({ objectMode: true })

  self._each_package(function on_package(item, cb) {
    fs.stat(item.path, function(err, stats) {
      if (err) return cb(err)

      if (stats.mtime &gt; startkey) {
        self.get_package(item.name, options, function(err, data) {
          if (err) return cb(err)

          var versions = Utils.semver_sort(Object.keys(data.versions))
          var latest = versions[versions.length - 1]

          if (data.versions[latest]) {
            stream.push({
              name           : data.versions[latest].name,
              description    : data.versions[latest].description,
              'dist-tags'    : { latest: latest },
              maintainers    : data.versions[latest].maintainers ||
                                 [ data.versions[latest]._npmUser ].filter(Boolean),
              author         : data.versions[latest].author,
              repository     : data.versions[latest].repository,
              readmeFilename : data.versions[latest].readmeFilename || '',
              homepage       : data.versions[latest].homepage,
              keywords       : data.versions[latest].keywords,
              bugs           : data.versions[latest].bugs,
              license        : data.versions[latest].license,
              time           : { modified: item.time ? new Date(item.time).toISOString() : undefined },
              versions       : {},
            })
          }

          cb()
        })
      } else {
        cb()
      }
    })
  }, function on_end(err) {
    if (err) return stream.emit('error', err)
    stream.end()
  })

  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.field('author'      , { boost:  6 })
  this.field('readme')
})
return self
}

Search.prototype.query = function(q) {
return this.index.<span class="apidocCodeKeywordSpan">search</span>(q)
}

Search.prototype.add = function(package) {
this.index.add({
  id:           package.name,
  name:         package.name,
  description:  package.description,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype.storage" id="apidoc.element.sinopia.local_storage.prototype.storage">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>storage
        <span class="apidocSignatureSpan">(package)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storage = function (package) {
  var path = this.config.get_package_spec(package).storage
  if (path == null) path = this.config.storage
  if (path == null || path === false) {
    this.logger.debug( { name: package }
                     , 'this package has no storage defined: @{name}' )
    return null
  }
  return Path_Wrapper(
    Path.join(
      Path.resolve(Path.dirname(this.config.self_path), path),
      package
    )
  )
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Storage.prototype._internal_error = function(err, file, message) {
this.logger.error( { err: err, file: file }
                 , message + ' @{file}: @{!err.message}' )
return Error[500]()
}

Storage.prototype.add_package = function(name, info, callback) {
var storage = this.<span class="apidocCodeKeywordSpan">storage</span>(name)
if (!storage) return callback( Error[404]('this package cannot be added') )

storage.create_json(info_file, get_boilerplate(name), function(err) {
  if (err &amp;&amp; err.code === 'EEXISTS') {
    return callback( Error[409]('this package is already present') )
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype.update_package" id="apidoc.element.sinopia.local_storage.prototype.update_package">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>update_package
        <span class="apidocSignatureSpan">(name, updateFn, _callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update_package = function (name, updateFn, _callback) {
  var self = this
  var storage = self.storage(name)
  if (!storage) return _callback( Error[404]('no such package available') )
  storage.lock_and_read_json(info_file, function(err, fd, json) {
    function callback() {
      var _args = arguments
      if (fd) {
        fs.close(fd, function(err) {
          if (err) return _callback(err)
          _callback.apply(null, _args)
        })
      } else {
        _callback.apply(null, _args)
      }
    }

    if (err) {
      if (err.code === 'EAGAIN') {
        return callback( Error[503]('resource temporarily unavailable') )
      } else if (err.code === 'ENOENT') {
        return callback( Error[404]('no such package available') )
      } else {
        return callback(err)
      }
    }

    self._normalize_package(json)
    updateFn(json, function(err) {
      if (err) return callback(err)

      self._write_package(name, json, callback)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  callback(null, data)
}
  })
}

Storage.prototype.add_version = function(name, version, metadata, tag, callback) {
  var self = this
  self.<span class="apidocCodeKeywordSpan">update_package</span>(name, function updater(data, cb) {
// keep only one readme per package
data.readme = metadata.readme
delete metadata.readme

if (data.versions[version] != null) {
  return cb( Error[409]('this version already present') )
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.local_storage.prototype.update_versions" id="apidoc.element.sinopia.local_storage.prototype.update_versions">
        function <span class="apidocSignatureSpan">sinopia.local_storage.prototype.</span>update_versions
        <span class="apidocSignatureSpan">(name, newdata, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update_versions = function (name, newdata, callback) {
  var self = this
  self._read_create_package(name, function(err, data) {
    if (err) return callback(err)

    var change = false
    for (var ver in newdata.versions) {
      if (data.versions[ver] == null) {
        var verdata = newdata.versions[ver]

        // we don't keep readmes for package versions,
        // only one readme per package
        delete verdata.readme

        change = true
        data.versions[ver] = verdata

        if (verdata.dist &amp;&amp; verdata.dist.tarball) {
          var filename = URL.parse(verdata.dist.tarball).pathname.replace(/^.*\//, '')
          // we do NOT overwrite any existing records
          if (data._distfiles[filename] == null) {
            var hash = data._distfiles[filename] = {
              url: verdata.dist.tarball,
              sha: verdata.dist.shasum,
            }

            if (verdata._sinopia_uplink) {
              // if we got this information from a known registry,
              // use the same protocol for the tarball
              //
              // see https://github.com/rlidwka/sinopia/issues/166
              var tarball_url = URL.parse(hash.url)
              var uplink_url  = URL.parse(self.config.uplinks[verdata._sinopia_uplink].url)
              if (uplink_url.host === tarball_url.host) {
                tarball_url.protocol = uplink_url.protocol
                hash.registry = verdata._sinopia_uplink
                hash.url = URL.format(tarball_url)
              }
            }
          }
        }
      }
    }
    for (var tag in newdata['dist-tags']) {
      if (!Array.isArray(data['dist-tags'][tag]) || data['dist-tags'][tag].length != newdata['dist-tags'][tag].length) {
        // backward compat
        var need_change = true
      } else {
        for (var i=0; i&lt;data['dist-tags'][tag].length; i++) {
          if (data['dist-tags'][tag][i] != newdata['dist-tags'][tag][i]) {
            var need_change = true
            break
          }
        }
      }

      if (need_change) {
        change = true
        data['dist-tags'][tag] = newdata['dist-tags'][tag]
      }
    }
    for (var up in newdata._uplinks) {
      var need_change = !Utils.is_object(data._uplinks[up])
                     || newdata._uplinks[up].etag !== data._uplinks[up].etag
                     || newdata._uplinks[up].fetched !== data._uplinks[up].fetched

      if (need_change) {
        change = true
        data._uplinks[up] = newdata._uplinks[up]
      }
    }
    if (newdata.readme !== data.readme) {
      data.readme = newdata.readme
      change = true
    }

    if (change) {
      self.logger.debug('updating package info')
      self._write_package(name, data, function(err) {
        callback(err, data)
      })
    } else {
      callback(null, data)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (!exists) {
      return callback( Error[404]('no such package available')
                     , null
                     , uplink_errors )
    }

    self.local.<span class="apidocCodeKeywordSpan">update_versions</span>(name, pkginfo, function(err, pkginfo) {
      if (err) return callback(err)
      return callback(null, pkginfo, uplink_errors)
    })
  })
}

// function gets a local info and an info from uplinks and tries to merge it
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.logger" id="apidoc.module.sinopia.logger">module sinopia.logger</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.logger.setup" id="apidoc.element.sinopia.logger.setup">
        function <span class="apidocSignatureSpan">sinopia.logger.</span>setup
        <span class="apidocSignatureSpan">(logs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setup = function (logs) {
  var streams = []
  if (logs == null) logs = [{ type: 'stdout', format: 'pretty', level: 'http' }]

  logs.forEach(function(target) {
    var stream = new Stream()
    stream.writable = true

    if (target.type === 'stdout' || target.type === 'stderr') {
      // destination stream
      var dest = target.type === 'stdout' ? process.stdout : process.stderr

      if (target.format === 'pretty') {
        // making fake stream for prettypritting
        stream.write = function(obj) {
          dest.write(print(obj.level, obj.msg, obj, dest.isTTY) + '\n')
        }
      } else {
        stream.write = function(obj) {
          dest.write(JSON.stringify(obj, Logger.safeCycles()) + '\n')
        }
      }
    } else if (target.type === 'file') {
      var dest = require('fs').createWriteStream(target.path, {flags: 'a', encoding: 'utf8'})
      dest.on('error', function (err) {
        Logger.emit('error', err)
      })
      stream.write = function(obj) {
        if (target.format === 'pretty') {
          dest.write(print(obj.level, obj.msg, obj, false) + '\n')
        } else {
          dest.write(JSON.stringify(obj, Logger.safeCycles()) + '\n')
        }
      }
    } else {
      throw Error('wrong target type for a log')
    }

    if (target.level === 'http') target.level = 35
    streams.push({
      type: 'raw',
      level: target.level || 35,
      stream: stream,
    })
  })

  var logger = new Logger({
    name: 'sinopia',
    streams: streams,
    serializers: {
      err: Logger.stdSerializers.err,
      req: Logger.stdSerializers.req,
      res: Logger.stdSerializers.res,
    },
  })

  module.exports.logger = logger
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.middleware" id="apidoc.module.sinopia.middleware">module sinopia.middleware</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.middleware.allow" id="apidoc.element.sinopia.middleware.allow">
        function <span class="apidocSignatureSpan">sinopia.middleware.</span>allow
        <span class="apidocSignatureSpan">(auth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allow = function (auth) {
  return function(action) {
    return function(req, res, next) {
      req.pause();
      auth['allow_'+action](req.params.package, req.remote_user, function(error, is_allowed) {
        req.resume();
        if (error) {
          next(error)
        } else if (is_allowed) {
          next()
        } else {
          // last plugin (that's our built-in one) returns either
          // cb(err) or cb(null, true), so this should never happen
          throw Error('bug in the auth plugin system')
        }
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.middleware.anti_loop" id="apidoc.element.sinopia.middleware.anti_loop">
        function <span class="apidocSignatureSpan">sinopia.middleware.</span>anti_loop
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anti_loop = function (config) {
  return function(req, res, next) {
    if (req.headers.via != null) {
      var arr = req.headers.via.split(',')

      for (var i=0; i&lt;arr.length; i++) {
        var m = arr[i].match(/\s*(\S+)\s+(\S+)/)
        if (m &amp;&amp; m[2] === config.server_id) {
          return next( Error[508]('loop detected') )
        }
      }
    }
    next()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.middleware.expect_json" id="apidoc.element.sinopia.middleware.expect_json">
        function <span class="apidocSignatureSpan">sinopia.middleware.</span>expect_json
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function expect_json(req, res, next) {
  if (!utils.is_object(req.body)) {
    return next( Error[400]("can't parse incoming json") )
  }
  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.middleware.final" id="apidoc.element.sinopia.middleware.final">
        function <span class="apidocSignatureSpan">sinopia.middleware.</span>final
        <span class="apidocSignatureSpan">(body, req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">final = function (body, req, res, next) {
  if (res.statusCode === 401 &amp;&amp; !res.getHeader('WWW-Authenticate')) {
    // they say it's required for 401, so...
    res.header('WWW-Authenticate', 'Basic, Bearer')
  }

  try {
    if (typeof(body) === 'string' || typeof(body) === 'object') {
      if (!res.getHeader('Content-type')) {
        res.header('Content-type', 'application/json')
      }

      if (typeof(body) === 'object' &amp;&amp; body != null) {
        if (typeof(body.error) === 'string') {
          res._sinopia_error = body.error
        }
        body = JSON.stringify(body, undefined, '  ') + '\n'
      }

      // don't send etags with errors
      if (!res.statusCode || (res.statusCode &gt;= 200 &amp;&amp; res.statusCode &lt; 300)) {
        res.header('ETag', '"' + md5sum(body) + '"')
      }
    } else {
      // send(null), send(204), etc.
    }
  } catch(err) {
    // if sinopia sends headers first, and then calls res.send()
    // as an error handler, we can't report error properly,
    // and should just close socket
    if (err.message.match(/set headers after they are sent/)) {
      if (res.socket != null) res.socket.destroy()
      return
    } else {
      throw err
    }
  }

  res.send(body)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

return data
}

Auth.prototype.aes_encrypt = function(buf) {
var c = Crypto.createCipher('aes192', this.secret)
var b1 = c.update(buf)
var b2 = c.<span class="apidocCodeKeywordSpan">final</span>()
return Buffer.concat([ b1, b2 ])
}

Auth.prototype.aes_decrypt = function(buf) {
try {
  var c = Crypto.createDecipher('aes192', this.secret)
  var b1 = c.update(buf)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.middleware.log" id="apidoc.element.sinopia.middleware.log">
        function <span class="apidocSignatureSpan">sinopia.middleware.</span>log
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (req, res, next) {
  // logger
  req.log = Logger.logger.child({ sub: 'in' })

  var _auth = req.headers.authorization
  if (_auth != null) req.headers.authorization = '&lt;Classified&gt;'
  var _cookie = req.headers.cookie
  if (_cookie != null) req.headers.cookie = '&lt;Classified&gt;'

  req.url = req.originalUrl
  req.log.info( { req: req, ip: req.ip }
              , '@{ip} requested \'@{req.method} @{req.url}\'' )
  req.originalUrl = req.url

  if (_auth != null) req.headers.authorization = _auth
  if (_cookie != null) req.headers.cookie = _cookie

  var bytesin = 0
  req.on('data', function(chunk) {
    bytesin += chunk.length
  })

  var bytesout = 0
  var _write = res.write
  res.write = function(buf) {
    bytesout += buf.length
    _write.apply(res, arguments)
  }

  function log() {
    var message = "@{status}, user: @{user}, req: '@{request.method} @{request.url}'"
    if (res._sinopia_error) {
      message += ', error: @{!error}'
    } else {
      message += ', bytes: @{bytes.in}/@{bytes.out}'
    }

    req.url = req.originalUrl
    req.log.warn({
      request : { method: req.method, url: req.url },
      level   : 35, // http
      user    : req.remote_user &amp;&amp; req.remote_user.name,
      status  : res.statusCode,
      error   : res._sinopia_error,
      bytes   : {
        in  : bytesin,
        out : bytesout,
      }
    }, message)
    req.originalUrl = req.url
  }

  req.on('close', function() {
    log(true)
  })

  var _end = res.end
  res.end = function(buf) {
    if (buf) bytesout += buf.length
    _end.apply(res, arguments)
    log()
  }
  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.middleware.match" id="apidoc.element.sinopia.middleware.match">
        function <span class="apidocSignatureSpan">sinopia.middleware.</span>match
        <span class="apidocSignatureSpan">(regexp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function match(regexp) {
  return function(req, res, next, value, name) {
    if (regexp.exec(value)) {
      next()
    } else {
      next('route')
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}

var users = {all:true, anonymous:true, 'undefined':true, owner:true, none:true}

var check_user_or_uplink = function(arg) {
  assert(arg !== 'all' &amp;&amp; arg !== 'owner' &amp;&amp; arg !== 'anonymous' &amp;&amp;
arg !== 'undefined' &amp;&amp; arg !== 'none', 'CONFIG: reserved user/uplink name: ' + arg)
  assert(!arg.<span class="apidocCodeKeywordSpan">match</span>(/\s/), 'CONFIG: invalid user name: ' + arg)
  assert(users[arg] == null, 'CONFIG: duplicate user/uplink name: ' + arg)
  users[arg] = true
}

;[ 'users', 'uplinks', 'packages' ].forEach(function(x) {
  if (self[x] == null) self[x] = {}
  assert(Utils.is_object(self[x]), 'CONFIG: bad "'+x+'" value (object expected)')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.middleware.media" id="apidoc.element.sinopia.middleware.media">
        function <span class="apidocSignatureSpan">sinopia.middleware.</span>media
        <span class="apidocSignatureSpan">(expect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function media(expect) {
  return function(req, res, next) {
    if (req.headers['content-type'] !== expect) {
      next( Error[415]('wrong content-type, expect: ' + expect
                     + ', got: '+req.headers['content-type']) )
    } else {
      next()
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.middleware.validate_name" id="apidoc.element.sinopia.middleware.validate_name">
        function <span class="apidocSignatureSpan">sinopia.middleware.</span>validate_name
        <span class="apidocSignatureSpan">(req, res, next, value, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validate_name(req, res, next, value, name) {
  if (value.charAt(0) === '-') {
    // special case in couchdb usually
    next('route')
  } else if (utils.validate_name(value)) {
    next()
  } else {
    next( Error[403]('invalid ' + name) )
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}, function(err) {
  if (err) return callback(err)
  callback()
})
}

Storage.prototype.remove_tarball = function(name, filename, revision, callback) {
assert(Utils.<span class="apidocCodeKeywordSpan">validate_name</span>(filename))
var self = this

self.update_package(name, function updater(data, cb) {
  if (data._attachments[filename]) {
    delete data._attachments[filename]
    cb()
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.middleware.validate_package" id="apidoc.element.sinopia.middleware.validate_package">
        function <span class="apidocSignatureSpan">sinopia.middleware.</span>validate_package
        <span class="apidocSignatureSpan">(req, res, next, value, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validate_package(req, res, next, value, name) {
  if (value.charAt(0) === '-') {
    // special case in couchdb usually
    next('route')
  } else if (utils.validate_package(value)) {
    next()
  } else {
    next( Error[403]('invalid ' + name) )
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}

module.exports.validate_package = function validate_package(req, res, next, value, name) {
  if (value.charAt(0) === '-') {
    // special case in couchdb usually
    next('route')
  } else if (utils.<span class="apidocCodeKeywordSpan">validate_package</span>(value)) {
    next()
  } else {
    next( Error[403]('invalid ' + name) )
  }
}

module.exports.media = function media(expect) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.plugin_loader" id="apidoc.module.sinopia.plugin_loader">module sinopia.plugin_loader</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.plugin_loader.load_plugins" id="apidoc.element.sinopia.plugin_loader.load_plugins">
        function <span class="apidocSignatureSpan">sinopia.plugin_loader.</span>load_plugins
        <span class="apidocSignatureSpan">(config, plugin_configs, params, sanity_check)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load_plugins(config, plugin_configs, params, sanity_check) {
  var plugins = Object.keys(plugin_configs || {}).map(function(p) {
    var plugin

    // npm package
    if (plugin == null &amp;&amp; p.match(/^[^\.\/]/)) {
      plugin = try_load('sinopia-' + p)
    }

    if (plugin == null) {
      plugin = try_load(p)
    }

    // relative to config path
    if (plugin == null &amp;&amp; p.match(/^\.\.?($|\/)/)) {
      plugin = try_load(Path.resolve(Path.dirname(config.self_path), p))
    }

    if (plugin == null) {
      throw Error('"' + p + '" plugin not found\n'
        + 'try "npm install sinopia-' + p + '"')
    }

    if (typeof(plugin) !== 'function')
      throw Error('"' + p + '" doesn\'t look like a valid plugin')

    plugin = plugin(plugin_configs[p], params)

    if (plugin == null || !sanity_check(plugin))
      throw Error('"' + p + '" doesn\'t look like a valid plugin')

    return plugin
  })

  return plugins
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.status_cats" id="apidoc.module.sinopia.status_cats">module sinopia.status_cats</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.status_cats.get_image" id="apidoc.element.sinopia.status_cats.get_image">
        function <span class="apidocSignatureSpan">sinopia.status_cats.</span>get_image
        <span class="apidocSignatureSpan">(status)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_image = function (status) {
  if (status in images) {
    return 'http://flic.kr/p/' + images[status]
    //return 'https://secure.flickr.com/photos/girliemac/'+images[status]+'/in/set-72157628409467125/lightbox/'
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}

module.exports.middleware = function(req, res, next) {
  var _writeHead = res.writeHead
  res.writeHead = function(status) {
    if (status in images) {
      res.setHeader('X-Status-Cat', module.exports.<span class="apidocCodeKeywordSpan">get_image</span>(status))
    }
    _writeHead.apply(res, arguments)
  }

  next()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.status_cats.middleware" id="apidoc.element.sinopia.status_cats.middleware">
        function <span class="apidocSignatureSpan">sinopia.status_cats.</span>middleware
        <span class="apidocSignatureSpan">(req, res, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">middleware = function (req, res, next) {
  var _writeHead = res.writeHead
  res.writeHead = function(status) {
    if (status in images) {
      res.setHeader('X-Status-Cat', module.exports.get_image(status))
    }
    _writeHead.apply(res, arguments)
  }

  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.storage" id="apidoc.module.sinopia.storage">module sinopia.storage</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.storage.storage" id="apidoc.element.sinopia.storage.storage">
        function <span class="apidocSignatureSpan">sinopia.</span>storage
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Storage(config) {
  var self = Object.create(Storage.prototype)
  self.config = config

  // we support a number of uplinks, but only one local storage
  // Proxy and Local classes should have similar API interfaces
  self.uplinks = {}
  for (var p in config.uplinks) {
    self.uplinks[p] = Proxy(config.uplinks[p], config)
    self.uplinks[p].upname = p
  }
  self.local = Local(config)
  self.logger = Logger.logger.child()

  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Storage.prototype._internal_error = function(err, file, message) {
this.logger.error( { err: err, file: file }
                 , message + ' @{file}: @{!err.message}' )
return Error[500]()
}

Storage.prototype.add_package = function(name, info, callback) {
var storage = this.<span class="apidocCodeKeywordSpan">storage</span>(name)
if (!storage) return callback( Error[404]('this package cannot be added') )

storage.create_json(info_file, get_boilerplate(name), function(err) {
  if (err &amp;&amp; err.code === 'EEXISTS') {
    return callback( Error[409]('this package is already present') )
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.storage._merge_versions" id="apidoc.element.sinopia.storage._merge_versions">
        function <span class="apidocSignatureSpan">sinopia.storage.</span>_merge_versions
        <span class="apidocSignatureSpan">(local, up, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_merge_versions = function (local, up, config) {
  // copy new versions to a cache
  // NOTE: if a certain version was updated, we can't refresh it reliably
  for (var i in up.versions) {
    if (local.versions[i] == null) {
      local.versions[i] = up.versions[i]
    }
  }

  // refresh dist-tags
  for (var i in up['dist-tags']) {
    var added = Utils.tag_version(local, up['dist-tags'][i], i, config || {})
    if (i === 'latest' &amp;&amp; added) {
      // if remote has more fresh package, we should borrow its readme
      local.readme = up.readme
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    enumerable   : false,
    configurable : false,
    writable     : true,
  })
}

try {
  Storage.<span class="apidocCodeKeywordSpan">_merge_versions</span>(pkginfo, up_res, self.config)
} catch(err) {
  self.logger.error({
    sub: 'out',
    err: err,
  }, 'package.json parsing error @{!err.message}\n@{err.stack}')
  return cb(null, [ err ])
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.storage.prototype" id="apidoc.module.sinopia.storage.prototype">module sinopia.storage.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.storage.prototype._sync_package_with_uplinks" id="apidoc.element.sinopia.storage.prototype._sync_package_with_uplinks">
        function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>_sync_package_with_uplinks
        <span class="apidocSignatureSpan">(name, pkginfo, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_sync_package_with_uplinks = function (name, pkginfo, options, callback) {
  var self = this

  if (!pkginfo) {
    var exists = false

    pkginfo = {
      name        : name,
      versions    : {},
      'dist-tags' : {},
      _uplinks    : {},
    }
  } else {
    var exists = true
  }

  var uplinks = []
  for (var i in self.uplinks) {
    if (self.config.can_proxy_to(name, i)) {
      uplinks.push(self.uplinks[i])
    }
  }

  async.map(uplinks, function(up, cb) {
    var _options = Object.assign({}, options)
    if (Utils.is_object(pkginfo._uplinks[up.upname])) {
      var fetched = pkginfo._uplinks[up.upname].fetched
      if (fetched &amp;&amp; fetched &gt; (Date.now() - up.maxage)) {
        return cb()
      }

      _options.etag = pkginfo._uplinks[up.upname].etag
    }

    up.get_package(name, _options, function(err, up_res, etag) {
      if (err &amp;&amp; err.status === 304)
        pkginfo._uplinks[up.upname].fetched = Date.now()

      if (err || !up_res) return cb(null, [err || Error('no data')])

      try {
        Utils.validate_metadata(up_res, name)
      } catch(err) {
        self.logger.error({
          sub: 'out',
          err: err,
        }, 'package.json validating error @{!err.message}\n@{err.stack}')
        return cb(null, [ err ])
      }

      pkginfo._uplinks[up.upname] = {
        etag: etag,
        fetched: Date.now()
      }

      for (var i in up_res.versions) {
        // this won't be serialized to json,
        // kinda like an ES6 Symbol
        Object.defineProperty(up_res.versions[i], '_sinopia_uplink', {
          value        : up.upname,
          enumerable   : false,
          configurable : false,
          writable     : true,
        })
      }

      try {
        Storage._merge_versions(pkginfo, up_res, self.config)
      } catch(err) {
        self.logger.error({
          sub: 'out',
          err: err,
        }, 'package.json parsing error @{!err.message}\n@{err.stack}')
        return cb(null, [ err ])
      }

      // if we got to this point, assume that the correct package exists
      // on the uplink
      exists = true
      cb()
    })
  }, function(err, uplink_errors) {
    assert(!err &amp;&amp; Array.isArray(uplink_errors))

    if (!exists) {
      return callback( Error[404]('no such package available')
                     , null
                     , uplink_errors )
    }

    self.local.update_versions(name, pkginfo, function(err, pkginfo) {
      if (err) return callback(err)
      return callback(null, pkginfo, uplink_errors)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (results) return cb( Error[409]('this package is already present') )

cb()
    })
  }

  function check_package_remote(cb) {
    self.<span class="apidocCodeKeywordSpan">_sync_package_with_uplinks</span>(name, null, {}, function(err, results, err_results
) {
// something weird
if (err &amp;&amp; err.status !== 404) return cb(err)

// checking package
if (results) return cb( Error[409]('this package is already present') )

for (var i=0; i&lt;err_results.length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.storage.prototype.add_package" id="apidoc.element.sinopia.storage.prototype.add_package">
        function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>add_package
        <span class="apidocSignatureSpan">(name, metadata, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add_package = function (name, metadata, callback) {
  var self = this

  // NOTE:
  // - when we checking package for existance, we ask ALL uplinks
  // - when we publishing package, we only publish it to some of them
  // so all requests are necessary

  check_package_local(function(err) {
    if (err) return callback(err)

    check_package_remote(function(err) {
      if (err) return callback(err)

      publish_package(function(err) {
        if (err) return callback(err)
        callback()
      })
    })
  })

  function check_package_local(cb) {
    self.local.get_package(name, {}, function(err, results) {
      if (err &amp;&amp; err.status !== 404) return cb(err)

      if (results) return cb( Error[409]('this package is already present') )

      cb()
    })
  }

  function check_package_remote(cb) {
    self._sync_package_with_uplinks(name, null, {}, function(err, results, err_results) {
      // something weird
      if (err &amp;&amp; err.status !== 404) return cb(err)

      // checking package
      if (results) return cb( Error[409]('this package is already present') )

      for (var i=0; i&lt;err_results.length; i++) {
        // checking error
        // if uplink fails with a status other than 404, we report failure
        if (err_results[i][0] != null) {
          if (err_results[i][0].status !== 404) {
            return cb( Error[503]('one of the uplinks is down, refuse to publish') )
          }
        }
      }

      return cb()
    })
  }

  function publish_package(cb) {
    self.local.add_package(name, metadata, callback)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }

      return cb()
    })
  }

  function publish_package(cb) {
    self.local.<span class="apidocCodeKeywordSpan">add_package</span>(name, metadata, callback)
  }
}

//
// Add a new version of package {name} to a system
//
// Used storages: local (write)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.storage.prototype.add_tarball" id="apidoc.element.sinopia.storage.prototype.add_tarball">
        function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>add_tarball
        <span class="apidocSignatureSpan">(name, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add_tarball = function (name, filename) {
  return this.local.add_tarball(name, filename)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Upload a tarball for {name} package
//
// Function is syncronous and returns a WritableStream
//
// Used storages: local (write)
//
Storage.prototype.add_tarball = function(name, filename) {
  return this.local.<span class="apidocCodeKeywordSpan">add_tarball</span>(name, filename)
}

//
// Get a tarball from a storage for {name} package
//
// Function is syncronous and returns a ReadableStream
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.storage.prototype.add_version" id="apidoc.element.sinopia.storage.prototype.add_version">
        function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>add_version
        <span class="apidocSignatureSpan">(name, version, metadata, tag, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add_version = function (name, version, metadata, tag, callback) {
  return this.local.add_version(name, version, metadata, tag, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//
// Add a new version of package {name} to a system
//
// Used storages: local (write)
//
Storage.prototype.add_version = function(name, version, metadata, tag, callback) {
  return this.local.<span class="apidocCodeKeywordSpan">add_version</span>(name, version, metadata, tag, callback)
}

//
// Tags a package version with a provided tag
//
// Used storages: local (write)
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.storage.prototype.change_package" id="apidoc.element.sinopia.storage.prototype.change_package">
        function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>change_package
        <span class="apidocSignatureSpan">(name, metadata, revision, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">change_package = function (name, metadata, revision, callback) {
  return this.local.change_package(name, metadata, revision, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
// Function changes a package info from local storage and all uplinks with
// write access.
//
// Used storages: local (write)
//
Storage.prototype.change_package = function(name, metadata, revision, callback) {
  return this.local.<span class="apidocCodeKeywordSpan">change_package</span>(name, metadata, revision, callback)
}

//
// Remove a package from a system
//
// Function removes a package from local storage
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.storage.prototype.get_local" id="apidoc.element.sinopia.storage.prototype.get_local">
        function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>get_local
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_local = function (callback) {
  var self = this
  var locals = this.config.localList.get()
  var packages = []

  var getPackage = function(i) {
    self.local.get_package(locals[i], function(err, info) {
      if (!err) {
        var latest = Array.isArray(info['dist-tags'].latest)
                   ? Utils.semver_sort(info['dist-tags'].latest).pop()
                   : info['dist-tags'].latest
        if (info.versions[latest]) {
          packages.push(info.versions[latest])
        } else {
          self.logger.warn( { package: locals[i] }
                          , 'package @{package} does not have a "latest" tag?' )
        }
      }

      if (i &gt;= locals.length - 1) {
        callback(null, packages)
      } else {
        getPackage(i + 1)
      }
    })
  }

  if (locals.length) {
    getPackage(0)
  } else {
    callback(null, [])
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Search.prototype.remove = function(name) {
  this.index.remove({ id: name })
}

Search.prototype.reindex = function() {
  var self = this
  this.storage.<span class="apidocCodeKeywordSpan">get_local</span>(function(err, packages) {
    if (err) throw err // that function shouldn't produce any
    var i = packages.length
    while (i--) {
      self.add(packages[i])
    }
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.storage.prototype.get_package" id="apidoc.element.sinopia.storage.prototype.get_package">
        function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>get_package
        <span class="apidocSignatureSpan">(name, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_package = function (name, options, callback) {
  if (typeof(options) === 'function') callback = options, options = {}

  var self = this

  self.local.get_package(name, options, function(err, data) {
    if (err &amp;&amp; (!err.status || err.status &gt;= 500)) {
      // report internal errors right away
      return callback(err)
    }

    self._sync_package_with_uplinks(name, data, options, function(err, result, uplink_errors) {
      if (err) return callback(err)
      var whitelist = [ '_rev', 'name', 'versions', 'dist-tags', 'readme' ]
      for (var i in result) {
        if (whitelist.indexOf(i) === -1) delete result[i]
      }

      if (self.config.ignore_latest_tag || !result['dist-tags'].latest) {
        result['dist-tags'].latest = Utils.semver_sort(Object.keys(result.versions))
      }

      for (var i in result['dist-tags']) {
        if (Array.isArray(result['dist-tags'][i])) {
          result['dist-tags'][i] = result['dist-tags'][i][result['dist-tags'][i].length-1]
          if (result['dist-tags'][i] == null) delete result['dist-tags'][i]
        }
      }

      // npm can throw if this field doesn't exist
      result._attachments = {}

      callback(null, result, uplink_errors)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var wstream = storage.write_stream(filename)

wstream.on('error', function(err) {
  if (err.code === 'EEXISTS') {
    stream.emit('error', Error[409]('this tarball is already present'))
  } else if (err.code === 'ENOENT') {
    // check if package exists to throw an appropriate message
    self.<span class="apidocCodeKeywordSpan">get_package</span>(name, function(_err, res) {
      if (_err) {
        stream.emit('error', _err)
      } else {
        stream.emit('error', err)
      }
    })
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.storage.prototype.get_tarball" id="apidoc.element.sinopia.storage.prototype.get_tarball">
        function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>get_tarball
        <span class="apidocSignatureSpan">(name, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_tarball = function (name, filename) {
  var stream = MyStreams.ReadTarballStream()
  stream.abort = function() {}

  var self = this

  // if someone requesting tarball, it means that we should already have some
  // information about it, so fetching package info is unnecessary

  // trying local first
  var rstream = self.local.get_tarball(name, filename)
  var is_open = false
  rstream.on('error', function(err) {
    if (is_open || err.status !== 404) {
      return stream.emit('error', err)
    }

    // local reported 404
    var err404 = err
    rstream.abort()
    rstream = null // gc

    self.local.get_package(name, function(err, info) {
      if (!err &amp;&amp; info._distfiles &amp;&amp; info._distfiles[filename] != null) {
        // information about this file exists locally
        serve_file(info._distfiles[filename])

      } else {
        // we know nothing about this file, trying to get information elsewhere

        self._sync_package_with_uplinks(name, info, {}, function(err, info) {
          if (err) return stream.emit('error', err)

          if (!info._distfiles || info._distfiles[filename] == null) {
            return stream.emit('error', err404)
          }

          serve_file(info._distfiles[filename])
        })
      }
    })
  })
  rstream.on('content-length', function(v) {
    stream.emit('content-length', v)
  })
  rstream.on('open', function() {
    is_open = true
    rstream.pipe(stream)
  })
  return stream

  function serve_file(file) {
    var uplink = null
    for (var p in self.uplinks) {
      if (self.uplinks[p].can_fetch_url(file.url)) {
        uplink = self.uplinks[p]
      }
    }
    if (uplink == null) {
      uplink = Proxy({
        url: file.url,
        _autogenerated: true,
      }, self.config)
    }

    var savestream = self.local.add_tarball(name, filename)
    var on_open = function() {
      on_open = function(){} // prevent it from being called twice
      var rstream2 = uplink.get_url(file.url)
      rstream2.on('error', function(err) {
        if (savestream) savestream.abort()
        savestream = null
        stream.emit('error', err)
      })
      rstream2.on('end', function() {
        if (savestream) savestream.done()
      })

      rstream2.on('content-length', function(v) {
        stream.emit('content-length', v)
        if (savestream) savestream.emit('content-length', v)
      })
      rstream2.pipe(stream)
      if (savestream) rstream2.pipe(savestream)
    }

    savestream.on('open', function() {
      on_open()
    })
    savestream.on('error', function(err) {
      self.logger.warn( { err: err }
                      , 'error saving file: @{err.message}\n@{err.stack}' )
      if (savestream) savestream.abort()
      savestream = null
      on_open()
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var self = this

  // if someone requesting tarball, it means that we should already have some
  // information about it, so fetching package info is unnecessary

  // trying local first
  var rstream = self.local.<span class="apidocCodeKeywordSpan">get_tarball</span>(name, filename)
  var is_open = false
  rstream.on('error', function(err) {
if (is_open || err.status !== 404) {
  return stream.emit('error', err)
}

// local reported 404
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.storage.prototype.merge_tags" id="apidoc.element.sinopia.storage.prototype.merge_tags">
        function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>merge_tags
        <span class="apidocSignatureSpan">(name, tag_hash, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge_tags = function (name, tag_hash, callback) {
  return this.local.merge_tags(name, tag_hash, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//
// Tags a package version with a provided tag
//
// Used storages: local (write)
//
Storage.prototype.merge_tags = function(name, tag_hash, callback) {
  return this.local.<span class="apidocCodeKeywordSpan">merge_tags</span>(name, tag_hash, callback)
}

//
// Tags a package version with a provided tag
//
// Used storages: local (write)
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.storage.prototype.remove_package" id="apidoc.element.sinopia.storage.prototype.remove_package">
        function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>remove_package
        <span class="apidocSignatureSpan">(name, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove_package = function (name, callback) {
  return this.local.remove_package(name, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Remove a package from a system
//
// Function removes a package from local storage
//
// Used storages: local (write)
//
Storage.prototype.remove_package = function(name, callback) {
  return this.local.<span class="apidocCodeKeywordSpan">remove_package</span>(name, callback)
}

//
// Remove a tarball from a system
//
// Function removes a tarball from local storage.
// Tarball in question should not be linked to in any existing
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.storage.prototype.remove_tarball" id="apidoc.element.sinopia.storage.prototype.remove_tarball">
        function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>remove_tarball
        <span class="apidocSignatureSpan">(name, filename, revision, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove_tarball = function (name, filename, revision, callback) {
  return this.local.remove_tarball(name, filename, revision, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Function removes a tarball from local storage.
// Tarball in question should not be linked to in any existing
// versions, i.e. package version should be unpublished first.
//
// Used storages: local (write)
//
Storage.prototype.remove_tarball = function(name, filename, revision, callback) {
  return this.local.<span class="apidocCodeKeywordSpan">remove_tarball</span>(name, filename, revision, callback)
}

//
// Upload a tarball for {name} package
//
// Function is syncronous and returns a WritableStream
//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.storage.prototype.replace_tags" id="apidoc.element.sinopia.storage.prototype.replace_tags">
        function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>replace_tags
        <span class="apidocSignatureSpan">(name, tag_hash, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace_tags = function (name, tag_hash, callback) {
  return this.local.replace_tags(name, tag_hash, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//
// Tags a package version with a provided tag
//
// Used storages: local (write)
//
Storage.prototype.replace_tags = function(name, tag_hash, callback) {
  return this.local.<span class="apidocCodeKeywordSpan">replace_tags</span>(name, tag_hash, callback)
}

//
// Change an existing package (i.e. unpublish one version)
//
// Function changes a package info from local storage and all uplinks with
// write access.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.storage.prototype.search" id="apidoc.element.sinopia.storage.prototype.search">
        function <span class="apidocSignatureSpan">sinopia.storage.prototype.</span>search
        <span class="apidocSignatureSpan">(startkey, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">search = function (startkey, options) {
  var self = this

  var stream = new Stream.PassThrough({ objectMode: true })

  async.eachSeries(Object.keys(self.uplinks), function(up_name, cb) {
    // shortcut: if `local=1` is supplied, don't call uplinks
    if (options.req.query.local !== undefined) return cb()

    var lstream = self.uplinks[up_name].search(startkey, options)
    lstream.pipe(stream, { end: false })
    lstream.on('error', function (err) {
      self.logger.error({ err: err }, 'uplink error: @{err.message}')
      cb(), cb = function () {}
    })
    lstream.on('end', function () {
      cb(), cb = function () {}
    })

    stream.abort = function () {
      if (lstream.abort) lstream.abort()
      cb(), cb = function () {}
    }
  }, function () {
    var lstream = self.local.search(startkey, options)
    stream.abort = function () { lstream.abort() }
    lstream.pipe(stream, { end: true })
    lstream.on('error', function (err) {
      self.logger.error({ err: err }, 'search error: @{err.message}')
      stream.end()
    })
  })

  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.field('author'      , { boost:  6 })
  this.field('readme')
})
return self
}

Search.prototype.query = function(q) {
return this.index.<span class="apidocCodeKeywordSpan">search</span>(q)
}

Search.prototype.add = function(package) {
this.index.add({
  id:           package.name,
  name:         package.name,
  description:  package.description,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.streams" id="apidoc.module.sinopia.streams">module sinopia.streams</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.streams.ReadTarballStream" id="apidoc.element.sinopia.streams.ReadTarballStream">
        function <span class="apidocSignatureSpan">sinopia.streams.</span>ReadTarballStream
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReadTarball(options) {
  var self = new Stream.PassThrough(options)
  Object.setPrototypeOf(self, ReadTarball.prototype)

  // called when data is not needed anymore
  add_abstract_method(self, 'abort')

  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (err) return stream.emit('error', err)
      stream.emit('content-length', stats.size)
      stream.emit('open')
      rstream.pipe(stream)
    })
  })

  var stream = MyStreams.<span class="apidocCodeKeywordSpan">ReadTarballStream</span>()
  stream.abort = function() {
    rstream.close()
  }
  return stream
}

function create(name, contents, callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.streams.UploadTarballStream" id="apidoc.element.sinopia.streams.UploadTarballStream">
        function <span class="apidocSignatureSpan">sinopia.streams.</span>UploadTarballStream
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UploadTarball(options) {
  var self = new Stream.PassThrough(options)
  Object.setPrototypeOf(self, UploadTarball.prototype)

  // called when user closes connection before upload finishes
  add_abstract_method(self, 'abort')

  // called when upload finishes successfully
  add_abstract_method(self, 'done')

  return self
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    cb(err)
  }
})
}

function write_stream(name) {
var stream = MyStreams.<span class="apidocCodeKeywordSpan">UploadTarballStream</span>()

var _ended = 0
stream.on('end', function() {
  _ended = 1
})

fs.exists(name, function(exists) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.up_storage" id="apidoc.module.sinopia.up_storage">module sinopia.up_storage</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.up_storage.up_storage" id="apidoc.element.sinopia.up_storage.up_storage">
        function <span class="apidocSignatureSpan">sinopia.</span>up_storage
        <span class="apidocSignatureSpan">(config, mainconfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Storage(config, mainconfig) {
  var self = Object.create(Storage.prototype)
  self.config = config
  self.failed_requests = 0
  self.userAgent = mainconfig.user_agent
  self.ca = config.ca
  self.logger = Logger.logger.child({sub: 'out'})
  self.server_id = mainconfig.server_id

  self.url = URL.parse(self.config.url)

  _setupProxy.call(self, self.url.hostname, config, mainconfig, self.url.protocol === 'https:')

  self.config.url = self.config.url.replace(/\/$/, '')
  if (Number(self.config.timeout) &gt;= 1000) {
    self.logger.warn([ 'Too big timeout value: ' + self.config.timeout,
                       'We changed time format to nginx-like one',
                       '(see http://wiki.nginx.org/ConfigNotation)',
                       'so please update your config accordingly' ].join('\n'))
  }

  // a bunch of different configurable timers
  self.maxage       = parse_interval(config_get('maxage'      , '2m' ))
  self.timeout      = parse_interval(config_get('timeout'     , '30s'))
  self.max_fails    =         Number(config_get('max_fails'   ,  2   ))
  self.fail_timeout = parse_interval(config_get('fail_timeout', '5m' ))
  return self

  // just a helper (`config[key] || default` doesn't work because of zeroes)
  function config_get(key, def) {
    return config[key] != null ? config[key] : def
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.up_storage.prototype" id="apidoc.module.sinopia.up_storage.prototype">module sinopia.up_storage.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.up_storage.prototype._add_proxy_headers" id="apidoc.element.sinopia.up_storage.prototype._add_proxy_headers">
        function <span class="apidocSignatureSpan">sinopia.up_storage.prototype.</span>_add_proxy_headers
        <span class="apidocSignatureSpan">(req, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_add_proxy_headers = function (req, headers) {
  if (req) {
    // Only submit X-Forwarded-For field if we don't have a proxy selected
    // in the config file.
    //
    // Otherwise misconfigured proxy could return 407:
    // https://github.com/rlidwka/sinopia/issues/254
    //
    if (!this.proxy) {
      headers['X-Forwarded-For'] = (
        req &amp;&amp; req.headers['x-forwarded-for']
        ? req.headers['x-forwarded-for'] + ', '
        : ''
      ) + req.connection.remoteAddress
    }
  }

  // always attach Via header to avoid loops, even if we're not proxying
  headers['Via'] =
    req &amp;&amp; req.headers['via']
    ? req.headers['via'] + ', '
    : ''

  headers['Via'] += '1.1 ' + this.server_id + ' (Sinopia)'
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var self = this
var headers = options.headers || {}
headers['Accept']          = headers['Accept']          || 'application/json'
headers['Accept-Encoding'] = headers['Accept-Encoding'] || 'gzip'
headers['User-Agent']      = headers['User-Agent']      || this.userAgent
this.<span class="apidocCodeKeywordSpan">_add_proxy_headers</span>(options.req, headers)

var method = options.method   || 'GET'
var uri    = options.uri_full || (this.config.url + options.uri)

self.logger.info({
  method  : method,
  headers : headers,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.up_storage.prototype.can_fetch_url" id="apidoc.element.sinopia.up_storage.prototype.can_fetch_url">
        function <span class="apidocSignatureSpan">sinopia.up_storage.prototype.</span>can_fetch_url
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">can_fetch_url = function (url) {
  url = URL.parse(url)

  return url.protocol === this.url.protocol
      &amp;&amp; url.host === this.url.host
      &amp;&amp; url.path.indexOf(this.url.path) === 0
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  rstream.pipe(stream)
})
return stream

function serve_file(file) {
  var uplink = null
  for (var p in self.uplinks) {
    if (self.uplinks[p].<span class="apidocCodeKeywordSpan">can_fetch_url</span>(file.url)) {
      uplink = self.uplinks[p]
    }
  }
  if (uplink == null) {
    uplink = Proxy({
      url: file.url,
      _autogenerated: true,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.up_storage.prototype.get_package" id="apidoc.element.sinopia.up_storage.prototype.get_package">
        function <span class="apidocSignatureSpan">sinopia.up_storage.prototype.</span>get_package
        <span class="apidocSignatureSpan">(name, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_package = function (name, options, callback) {
  if (typeof(options) === 'function') callback = options, options = {}

  var headers = {}
  if (options.etag) {
    headers['If-None-Match'] = options.etag
    headers['Accept']        = 'application/octet-stream'
  }

  this.request({
    uri     : '/' + encode(name),
    json    : true,
    headers : headers,
    req     : options.req,
  }, function(err, res, body) {
    if (err) return callback(err)
    if (res.statusCode === 404) {
      return callback( Error[404]("package doesn't exist on uplink") )
    }
    if (!(res.statusCode &gt;= 200 &amp;&amp; res.statusCode &lt; 300)) {
      var error = Error('bad status code: ' + res.statusCode)
      error.remoteStatus = res.statusCode
      return callback(error)
    }
    callback(null, body, res.headers.etag)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var wstream = storage.write_stream(filename)

wstream.on('error', function(err) {
  if (err.code === 'EEXISTS') {
    stream.emit('error', Error[409]('this tarball is already present'))
  } else if (err.code === 'ENOENT') {
    // check if package exists to throw an appropriate message
    self.<span class="apidocCodeKeywordSpan">get_package</span>(name, function(_err, res) {
      if (_err) {
        stream.emit('error', _err)
      } else {
        stream.emit('error', err)
      }
    })
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.up_storage.prototype.get_tarball" id="apidoc.element.sinopia.up_storage.prototype.get_tarball">
        function <span class="apidocSignatureSpan">sinopia.up_storage.prototype.</span>get_tarball
        <span class="apidocSignatureSpan">(name, options, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_tarball = function (name, options, filename) {
  if (!options) options = {}
  return this.get_url(this.config.url + '/' + name + '/-/' + filename)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var self = this

  // if someone requesting tarball, it means that we should already have some
  // information about it, so fetching package info is unnecessary

  // trying local first
  var rstream = self.local.<span class="apidocCodeKeywordSpan">get_tarball</span>(name, filename)
  var is_open = false
  rstream.on('error', function(err) {
if (is_open || err.status !== 404) {
  return stream.emit('error', err)
}

// local reported 404
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.up_storage.prototype.get_url" id="apidoc.element.sinopia.up_storage.prototype.get_url">
        function <span class="apidocSignatureSpan">sinopia.up_storage.prototype.</span>get_url
        <span class="apidocSignatureSpan">(url)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_url = function (url) {
  var stream = MyStreams.ReadTarballStream()
  stream.abort = function() {}
  var current_length = 0, expected_length

  var rstream = this.request({
    uri_full: url,
    encoding: null,
    headers: { Accept: 'application/octet-stream' },
  })

  rstream.on('response', function(res) {
    if (res.statusCode === 404) {
      return stream.emit('error', Error[404]("file doesn't exist on uplink"))
    }
    if (!(res.statusCode &gt;= 200 &amp;&amp; res.statusCode &lt; 300)) {
      return stream.emit('error', Error('bad uplink status code: ' + res.statusCode))
    }
    if (res.headers['content-length']) {
      expected_length = res.headers['content-length']
      stream.emit('content-length', res.headers['content-length'])
    }

    rstream.pipe(stream)
  })

  rstream.on('error', function(err) {
    stream.emit('error', err)
  })
  rstream.on('data', function(d) {
    current_length += d.length
  })
  rstream.on('end', function(d) {
    if (d) current_length += d.length
    if (expected_length &amp;&amp; current_length != expected_length)
      stream.emit('error', Error('content length mismatch'))
  })
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    _autogenerated: true,
  }, self.config)
}

var savestream = self.local.add_tarball(name, filename)
var on_open = function() {
  on_open = function(){} // prevent it from being called twice
  var rstream2 = uplink.<span class="apidocCodeKeywordSpan">get_url</span>(file.url)
  rstream2.on('error', function(err) {
    if (savestream) savestream.abort()
    savestream = null
    stream.emit('error', err)
  })
  rstream2.on('end', function() {
    if (savestream) savestream.done()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.up_storage.prototype.request" id="apidoc.element.sinopia.up_storage.prototype.request">
        function <span class="apidocSignatureSpan">sinopia.up_storage.prototype.</span>request
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">request = function (options, cb) {
  if (!this.status_check()) {
    var req = new Stream.Readable()
    process.nextTick(function() {
      if (typeof(cb) === 'function') cb(Error('uplink is offline'))
      req.emit('error', Error('uplink is offline'))
    })
    // preventing 'Uncaught, unspecified "error" event'
    req.on('error', function(){})
    return req
  }

  var self = this
  var headers = options.headers || {}
  headers['Accept']          = headers['Accept']          || 'application/json'
  headers['Accept-Encoding'] = headers['Accept-Encoding'] || 'gzip'
  headers['User-Agent']      = headers['User-Agent']      || this.userAgent
  this._add_proxy_headers(options.req, headers)

  var method = options.method   || 'GET'
  var uri    = options.uri_full || (this.config.url + options.uri)

  self.logger.info({
    method  : method,
    headers : headers,
    uri     : uri,
  }, "making request: '@{method} @{uri}'")

  if (Utils.is_object(options.json)) {
    var json = JSON.stringify(options.json)
    headers['Content-Type'] = headers['Content-Type'] || 'application/json'
  }

  var request_callback = cb ? (function (err, res, body) {
    var error
    var res_length = err ? 0 : body.length

    do_decode()
    do_log()
    cb(err, res, body)

    function do_decode() {
      if (err) {
        error = err.message
        return
      }

      if (options.json &amp;&amp; res.statusCode &lt; 300) {
        try {
          body = JSON.parse(body.toString('utf8'))
        } catch(_err) {
          body = {}
          err = _err
          error = err.message
        }
      }

      if (!err &amp;&amp; Utils.is_object(body)) {
        if (typeof(body.error) === 'string') {
          error = body.error
        }
      }
    }

    function do_log() {
      var message = '@{!status}, req: \'@{request.method} @{request.url}\''
      message += error
               ? ', error: @{!error}'
               : ', bytes: @{bytes.in}/@{bytes.out}'
      self.logger.warn({
        err     : err,
        request : { method: method, url: uri },
        level   : 35, // http
        status  : res != null ? res.statusCode : 'ERR',
        error   : error,
        bytes   : {
          in  : json ? json.length : 0,
          out : res_length || 0,
        }
      }, message)
    }
  }) : undefined

  var req = request({
    url      : uri,
    method   : method,
    headers  : headers,
    body     : json,
    ca       : this.ca,
    proxy    : this.proxy,
    encoding : null,
    gzip     : true,
    timeout  : this.timeout,
  }, request_callback)

  var status_called = false
  req.on('response', function(res) {
    if (!req._sinopia_aborted &amp;&amp; !status_called) {
      status_called = true
      self.status_check(true)
    }

    if (!request_callback) {
      ;(function do_log() {
        var message = '@{!status}, req: \'@{request.method} @{request.url}\' (streaming)'
        self.logger.warn({
          request : { method: method, url: uri },
          level   : 35, // http
          status  : res != null ? res.statusCode : 'ERR',
        }, message)
      })()
    }
  })
  req.on('error', function(_err) {
    if (!req._sinopia_aborted &amp;&amp; !status_called) {
      status_called = true
      self.status_check(false)
    }
  })
  return req
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var headers = {}
if (options.etag) {
  headers['If-None-Match'] = options.etag
  headers['Accept']        = 'application/octet-stream'
}

this.<span class="apidocCodeKeywordSpan">request</span>({
  uri     : '/' + encode(name),
  json    : true,
  headers : headers,
  req     : options.req,
}, function(err, res, body) {
  if (err) return callback(err)
  if (res.statusCode === 404) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.up_storage.prototype.search" id="apidoc.element.sinopia.up_storage.prototype.search">
        function <span class="apidocSignatureSpan">sinopia.up_storage.prototype.</span>search
        <span class="apidocSignatureSpan">(startkey, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">search = function (startkey, options) {
  var self = this

  var stream = new Stream.PassThrough({ objectMode: true })

  var req = self.request({
    uri: options.req.url,
    req: options.req,
  })

  req.on('response', function (res) {
    if (!String(res.statusCode).match(/^2\d\d$/)) {
      return stream.emit('error', Error('bad status code ' + res.statusCode + ' from uplink'))
    }

    res.pipe(JSONStream.parse('*')).on('data', function (pkg) {
      if (Utils.is_object(pkg)) {
        stream.emit('data', pkg)
      }
    })

    res.on('end', function () {
      stream.emit('end')
    })
  })

  req.on('error', function (err) {
    stream.emit('error', err)
  })

  stream.abort = function () {
    req.abort()
    stream.emit('end')
  }

  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.field('author'      , { boost:  6 })
  this.field('readme')
})
return self
}

Search.prototype.query = function(q) {
return this.index.<span class="apidocCodeKeywordSpan">search</span>(q)
}

Search.prototype.add = function(package) {
this.index.add({
  id:           package.name,
  name:         package.name,
  description:  package.description,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.up_storage.prototype.status_check" id="apidoc.element.sinopia.up_storage.prototype.status_check">
        function <span class="apidocSignatureSpan">sinopia.up_storage.prototype.</span>status_check
        <span class="apidocSignatureSpan">(alive)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">status_check = function (alive) {
  if (arguments.length === 0) {
    if (this.failed_requests &gt;= this.max_fails
     &amp;&amp; Math.abs(Date.now() - this.last_request_time) &lt; this.fail_timeout) {
      return false
    } else {
      return true
    }
  } else {
    if (alive) {
      if (this.failed_requests &gt;= this.max_fails) {
        this.logger.warn({ host: this.url.host }, 'host @{host} is back online')
      }
      this.failed_requests = 0
    } else {
      this.failed_requests++
      if (this.failed_requests === this.max_fails) {
        this.logger.warn({ host: this.url.host }, 'host @{host} is now offline')
      }
    }
    this.last_request_time = Date.now()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
  this.logger.debug( { url: this.url.href, proxy: this.proxy }
                   , 'using proxy @{proxy} for @{url}' )
}
}

Storage.prototype.request = function(options, cb) {
if (!this.<span class="apidocCodeKeywordSpan">status_check</span>()) {
  var req = new Stream.Readable()
  process.nextTick(function() {
    if (typeof(cb) === 'function') cb(Error('uplink is offline'))
    req.emit('error', Error('uplink is offline'))
  })
  // preventing 'Uncaught, unspecified "error" event'
  req.on('error', function(){})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.sinopia.utils" id="apidoc.module.sinopia.utils">module sinopia.utils</a></h1>


    <h2>
        <a href="#apidoc.element.sinopia.utils.filter_tarball_urls" id="apidoc.element.sinopia.utils.filter_tarball_urls">
        function <span class="apidocSignatureSpan">sinopia.utils.</span>filter_tarball_urls
        <span class="apidocSignatureSpan">(pkg, req, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter_tarball_urls = function (pkg, req, config) {
  function filter(_url) {
    if (!req.headers.host) return _url

    var filename = URL.parse(_url).pathname.replace(/^.*\//, '')

    if (config.url_prefix != null) {
      var result = config.url_prefix.replace(/\/$/, '')
    } else {
      var result = req.protocol + '://' + req.headers.host
    }

    return result + '/' + pkg.name.replace(/\//g, '%2f') + '/-/' + filename
  }

  for (var ver in pkg.versions) {
    var dist = pkg.versions[ver].dist
    if (dist != null &amp;&amp; dist.tarball != null) {
      //dist.__sinopia_orig_tarball = dist.tarball
      dist.tarball = filter(dist.tarball)
    }
  }
  return pkg
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.utils.get_version" id="apidoc.element.sinopia.utils.get_version">
        function <span class="apidocSignatureSpan">sinopia.utils.</span>get_version
        <span class="apidocSignatureSpan">(object, version)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_version = function (object, version) {
  if (object.versions[version] != null) return object.versions[version]

  try {
    version = Semver.parse(version, true)
    for (var k in object.versions) {
      if (version.compare(Semver.parse(k, true)) === 0) {
        return object.versions[k]
      }
    }
  } catch (err) {
    return undefined
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.utils.is_object" id="apidoc.element.sinopia.utils.is_object">
        function <span class="apidocSignatureSpan">sinopia.utils.</span>is_object
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">is_object = function (obj) {
  return typeof(obj) === 'object' &amp;&amp; obj !== null &amp;&amp; !Array.isArray(obj)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  assert(!arg.match(/\s/), 'CONFIG: invalid user name: ' + arg)
  assert(users[arg] == null, 'CONFIG: duplicate user/uplink name: ' + arg)
  users[arg] = true
}

;[ 'users', 'uplinks', 'packages' ].forEach(function(x) {
  if (self[x] == null) self[x] = {}
  assert(Utils.<span class="apidocCodeKeywordSpan">is_object</span>(self[x]), 'CONFIG: bad "'+x+'" value
 (object expected)')
})

for (var i in self.users) check_user_or_uplink(i)
for (var i in self.uplinks) check_user_or_uplink(i)

for (var i in self.users) {
  assert(self.users[i].password, 'CONFIG: no password for user: ' + i)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.utils.parse_address" id="apidoc.element.sinopia.utils.parse_address">
        function <span class="apidocSignatureSpan">sinopia.utils.</span>parse_address
        <span class="apidocSignatureSpan">(addr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse_address(addr) {
  //
  // Allow:
  //
  //  - https:localhost:1234        - protocol + host + port
  //  - localhost:1234              - host + port
  //  - 1234                        - port
  //  - http::1234                  - protocol + port
  //  - https://localhost:443/      - full url + https
  //  - http://[::1]:443/           - ipv6
  //  - unix:/tmp/http.sock         - unix sockets
  //  - https://unix:/tmp/http.sock - unix sockets (https)
  //
  // TODO: refactor it to something more reasonable?
  //
  //        protocol :  //      (  host  )|(    ipv6     ):  port  /
  var m = /^((https?):(\/\/)?)?((([^\/:]*)|\[([^\[\]]+)\]):)?(\d+)\/?$/.exec(addr)

  if (m) return {
    proto: m[2] || 'http',
    host:  m[6] || m[7] || 'localhost',
    port:  m[8] || '4873',
  }

  var m = /^((https?):(\/\/)?)?unix:(.*)$/.exec(addr)

  if (m) return {
    proto: m[2] || 'http',
    path:  m[4],
  }

  return null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.utils.semver_sort" id="apidoc.element.sinopia.utils.semver_sort">
        function <span class="apidocSignatureSpan">sinopia.utils.</span>semver_sort
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function semver_sort(array) {
  return array
        .filter(function(x) {
          if (!Semver.parse(x, true)) {
            Logger.logger.warn( {ver: x}, 'ignoring bad version @{ver}' )
            return false
          }
          return true
        })
        .sort(Semver.compareLoose)
        .map(String)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    fs.stat(item.path, function(err, stats) {
      if (err) return cb(err)

      if (stats.mtime &gt; startkey) {
        self.get_package(item.name, options, function(err, data) {
if (err) return cb(err)

var versions = Utils.<span class="apidocCodeKeywordSpan">semver_sort</span>(Object.keys(data.versions))
var latest = versions[versions.length - 1]

if (data.versions[latest]) {
  stream.push({
    name           : data.versions[latest].name,
    description    : data.versions[latest].description,
    'dist-tags'    : { latest: latest },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.utils.tag_version" id="apidoc.element.sinopia.utils.tag_version">
        function <span class="apidocSignatureSpan">sinopia.utils.</span>tag_version
        <span class="apidocSignatureSpan">(data, version, tag, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tag_version = function (data, version, tag, config) {
  if (!can_add_tag(tag, config)) return false

  switch (typeof(data['dist-tags'][tag])) {
    case 'string':
      data['dist-tags'][tag] = [ data['dist-tags'][tag] ]
      break
    case 'object': // array
      break
    default:
      data['dist-tags'][tag] = []
  }
  if (data['dist-tags'][tag].indexOf(version) === -1) {
    data['dist-tags'][tag].push(version)
    data['dist-tags'][tag] = module.exports.semver_sort(data['dist-tags'][tag])
    return data['dist-tags'][tag][data['dist-tags'][tag].length - 1] === version
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }

      data._attachments[tarball].version = version
    }
  }

  data.versions[version] = metadata
  Utils.<span class="apidocCodeKeywordSpan">tag_version</span>(data, version, tag, self.config)
  self.config.localList.add(name)
  cb()
}, callback)
}

Storage.prototype.merge_tags = function(name, tags, callback) {
var self = this
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.utils.validate_metadata" id="apidoc.element.sinopia.utils.validate_metadata">
        function <span class="apidocSignatureSpan">sinopia.utils.</span>validate_metadata
        <span class="apidocSignatureSpan">(object, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_metadata = function (object, name) {
  assert(module.exports.is_object(object), 'not a json object')
  assert.equal(object.name, name)

  if (!module.exports.is_object(object['dist-tags'])) {
    object['dist-tags'] = {}
  }

  if (!module.exports.is_object(object['versions'])) {
    object['versions'] = {}
  }

  return object
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    up.get_package(name, _options, function(err, up_res, etag) {
if (err &amp;&amp; err.status === 304)
  pkginfo._uplinks[up.upname].fetched = Date.now()

if (err || !up_res) return cb(null, [err || Error('no data')])

try {
  Utils.<span class="apidocCodeKeywordSpan">validate_metadata</span>(up_res, name)
} catch(err) {
  self.logger.error({
    sub: 'out',
    err: err,
  }, 'package.json validating error @{!err.message}\n@{err.stack}')
  return cb(null, [ err ])
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.utils.validate_name" id="apidoc.element.sinopia.utils.validate_name">
        function <span class="apidocSignatureSpan">sinopia.utils.</span>validate_name
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_name = function (name) {
  if (typeof(name) !== 'string') return false
  name = name.toLowerCase()

  // all URL-safe characters and "@" for issue #75
  if (!name.match(/^[-a-zA-Z0-9_.!~*'()@]+$/)
   || name.charAt(0) === '.' // ".bin", etc.
   || name.charAt(0) === '-' // "-" is reserved by couchdb
   || name === 'node_modules'
   || name === '__proto__'
   || name === 'package.json'
   || name === 'favicon.ico'
  ) {
    return false
  } else {
    return true
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}, function(err) {
  if (err) return callback(err)
  callback()
})
}

Storage.prototype.remove_tarball = function(name, filename, revision, callback) {
assert(Utils.<span class="apidocCodeKeywordSpan">validate_name</span>(filename))
var self = this

self.update_package(name, function updater(data, cb) {
  if (data._attachments[filename]) {
    delete data._attachments[filename]
    cb()
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.sinopia.utils.validate_package" id="apidoc.element.sinopia.utils.validate_package">
        function <span class="apidocSignatureSpan">sinopia.utils.</span>validate_package
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_package = function (name) {
  name = name.split('/', 2)
  if (name.length === 1) {
    // normal package
    return module.exports.validate_name(name[0])
  } else {
    // scoped package
    return name[0][0] === '@'
        &amp;&amp; module.exports.validate_name(name[0].slice(1))
        &amp;&amp; module.exports.validate_name(name[1])
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}

module.exports.validate_package = function validate_package(req, res, next, value, name) {
  if (value.charAt(0) === '-') {
    // special case in couchdb usually
    next('route')
  } else if (utils.<span class="apidocCodeKeywordSpan">validate_package</span>(value)) {
    next()
  } else {
    next( Error[403]('invalid ' + name) )
  }
}

module.exports.media = function media(expect) {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>